{
  "main.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   main.c                                             :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/14 16:26:03 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/14 16:26:16 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n#include \"EXECUTION/execution.h\"\n#include <termios.h>\n#include <stdlib.h>\n\nvolatile sig_atomic_t\tg_signal_received = 0;\n\nstatic void\tsignal_handler(int sig)\n{\n\tg_signal_received = sig;\n\tif (sig == SIGINT)\n\t{\n\t\twrite(1, \"\\n\", 1);\n\t\trl_on_new_line();\n\t\trl_replace_line(\"\", 0);\n\t\trl_redisplay();\n\t}\n}\n\nstatic void\tinitialize_shell(t_shell *shell, char **envp)\n{\n\tstruct sigaction\tsa;\n\tchar\t\t\t\tcwd_buffer[1024];\n\n\tshell->envp = dupenv(envp);\n\tshell->last_exit_status = 0;\n\tif (getcwd(cwd_buffer, sizeof(cwd_buffer)) != NULL)\n\t{\n\t\tset_env(\"PWD\", cwd_buffer, shell);\n\t}\n\telse\n\t{\n\t\tperror(\"minishell: startup error\");\n\t\texit(1);\n\t}\n\tg_signal_received = 0;\n\trl_catch_signals = 0;\n\tsa.sa_handler = signal_handler;\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = 0;\n\tsigaction(SIGINT, &sa, NULL);\n\tsignal(SIGQUIT, SIG_IGN);\n}\n\nstatic void\tprocess_input_line(char *line, t_shell *shell, struct termios *term)\n{\n\tt_token\t\t\t\t*tokens;\n\tt_command\t\t\t*commands;\n\tstruct sigaction\tsa;\n\n\tif (*line)\n\t\tadd_history(line);\n\ttokens = tokenizer(line);\n\tcommands = parser(tokens);\n\tif (commands)\n\t{\n\t\tsignal(SIGINT, SIG_IGN);\n\t\tif (process_heredoc_pipe(commands, shell))\n\t\t{\n\t\t\tif (main_expand(commands, shell))\n\t\t\t\t(quote_remover(commands), executor(commands, shell));\n\t\t\telse\n\t\t\t\tshell->last_exit_status = 1;\n\t\t}\n\t\ttcsetattr(0, TCSANOW, term);\n\t\tsa.sa_handler = signal_handler;\n\t\tsigemptyset(&sa.sa_mask);\n\t\tsa.sa_flags = 0;\n\t\tsigaction(SIGINT, &sa, NULL);\n\t}\n\t(free(line), gc_freed());\n}\n\nstatic void\tshell_loop(t_shell *shell, struct termios *term)\n{\n\tchar\t*line;\n\n\twhile (1)\n\t{\n\t\tif (g_signal_received == SIGINT)\n\t\t{\n\t\t\tshell->last_exit_status = 130;\n\t\t\tg_signal_received = 0;\n\t\t}\n\t\tline = readline(\"minishell> \");\n\t\tif (!line)\n\t\t{\n\t\t\tft_putstr_fd(\"exit\\n\", 1);\n\t\t\tbreak ;\n\t\t}\n\t\tprocess_input_line(line, shell, term);\n\t}\n}\n\nint\tmain(int argc, char **argv, char **envp)\n{\n\tt_shell\t\t\tshell;\n\tstruct termios\tterm;\n\n\t(void)argc;\n\t(void)argv;\n\tinitialize_shell(&shell, envp);\n\ttcgetattr(0, &term);\n\tshell_loop(&shell, &term);\n\tfree_env(shell.envp);\n\tgc_freed();\n\treturn (shell.last_exit_status);\n}",
  "Makefile": "NAME = minishell\n\nCC = cc\nCFLAGS = -Wall -Wextra -Werror\nRM = rm -f\n\nREADLINE_PATH = /mnt/homes/oben-jha/homebrew/opt/readline\n\nINCLUDES = -I. \\\n           -IEXECUTION \\\n           -IEXECUTION/builtins \\\n           -IEXPAND \\\n           -IPARSER \\\n           -IPARSER/nodes \\\n           -ITOKENIZER \\\n           -IGARBAGE_COLLECTOR \\\n           -IHEREDOC \\\n           -Itools \\\n           -I$(READLINE_PATH)/include \n\n\nLDFLAGS = -L$(READLINE_PATH)/lib -lreadline\n\nSRCS = main.c \\\n       EXECUTION/builtins_dispatch.c \\\n       EXECUTION/env_utils.c \\\n       EXECUTION/executor.c \\\n       EXECUTION/path_finder.c \\\n       EXECUTION/redirections.c \\\n       EXECUTION/builtins/ft_cd.c \\\n       EXECUTION/builtins/ft_echo.c \\\n       EXECUTION/builtins/ft_env.c \\\n       EXECUTION/builtins/ft_exit.c \\\n       EXECUTION/builtins/ft_export.c \\\n       EXECUTION/builtins/ft_pwd.c \\\n       EXECUTION/builtins/ft_unset.c \\\n       EXPAND/expand.c \\\n       EXPAND/g_expand.c \\\n       EXPAND/helper.c \\\n       EXPAND/quotes_removal.c \\\n       EXPAND/utils.c \\\n       GARBAGE_COLLECTOR/gc_mall.c \\\n       GARBAGE_COLLECTOR/gc_mall2.c \\\n       HEREDOC/processor.c \\\n       PARSER/error_handler.c \\\n       PARSER/processor.c \\\n       PARSER/redirections.c \\\n       PARSER/nodes/cmd_nodes.c \\\n       PARSER/nodes/redir_nodes.c \\\n       TOKENIZER/nodes.c \\\n       TOKENIZER/operators.c \\\n       TOKENIZER/tokenizer.c \\\n       TOKENIZER/tools.c \\\n       TOKENIZER/words.c \\\n       tools/strings.c\n\nOBJS = $(SRCS:.c=.o)\n\nall: $(NAME)\n\n$(NAME): $(OBJS)\n\t$(CC) $(OBJS) $(LDFLAGS) -o $(NAME)\n\n%.o: %.c\n\t$(CC) $(CFLAGS) $(INCLUDES) -c $< -o $@\n\nclean:\n\t$(RM) $(OBJS)\n\nfclean: clean\n\t$(RM) $(NAME)\n\nre: fclean all\n\n.PHONY: all clean fclean re",
  "parsing.h": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   parsing.h                                          :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/12 23:08:26 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/14 18:21:56 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#ifndef PARSING_H\n# define PARSING_H\n\n# include <stdlib.h>\n# include <stddef.h>\n# include <stdio.h>\n# include <stdbool.h>\n# include <unistd.h>\n# include <readline/readline.h>\n# include <readline/history.h>\n# include <signal.h>\n# include <sys/wait.h>\n\ntypedef struct s_shell\n{\n\tchar\t**envp;\n\tint\t\tlast_exit_status;\n}\tt_shell;\n\ntypedef struct s_gc_node\n{\n\tvoid\t\t\t\t*pt;\n\tstruct s_gc_node\t*next;\n}\tt_gc_node;\n\ntypedef enum e_token_type\n{\n\tTOKEN_WORD,\n\tTOKEN_PIPE,\n\tTOKEN_REDIR_IN,\n\tTOKEN_REDIR_OUT,\n\tTOKEN_REDIR_APPEND,\n\tTOKEN_REDIR_HEREDOC,\n\tTOKEN_NEWLINE,\n\tTOKEN_EOF,\n\tTOKEN_ERROR\n}\tt_token_type;\n\ntypedef struct s_token\n{\n\tt_token_type\ttype;\n\tchar\t\t\t*value;\n\tstruct s_token\t*next;\n}\tt_token;\n\ntypedef enum e_redir_type\n{\n\tREDIR_NONE,\n\tREDIR_INPUT,\n\tREDIR_OUTPUT_TRUNC,\n\tREDIR_OUTPUT_APPEND,\n\tREDIR_HEREDOC\n}\tt_redir_type;\n\ntypedef struct s_redir\n{\n\tt_redir_type\ttype;\n\tchar\t\t\t*del_or_fname;\n\tint\t\t\t\theredoc_fd;\n\tbool\t\t\texpand_in_heredoc;\n\tstruct s_redir\t*next;\n}\tt_redir;\n\ntypedef struct s_command\n{\n\tchar\t\t\t\t**args;\n\tt_redir\t\t\t\t*redirections;\n\tstruct s_command\t*next_piped_command;\n}\tt_command;\n\ntypedef struct s_arg_list\n{\n\tchar\t\t\t\t*arg;\n\tstruct s_arg_list\t*next;\n}\tt_arg_list;\n\ntypedef struct s_exp_data\n{\n\tt_shell\t\t\t\t*shell;\n\tint\t\t\t\t\t*flag;\n\tstruct\ts_exp_data\t*next;\n} t_exp_data;\n\nvoid\t\tgc_add_pt(void *pt);\nvoid\t\t*gc_mall(size_t size);\nchar\t\t*gc_strdup(char *str);\nvoid\t\tgc_freed(void);\nchar\t\t*gc_substr(char const *s, unsigned int start, size_t len);\nchar\t\t*gc_strjoin(char const *s1, char const *s2);\nchar\t\t*gc_itoa(int n);\n\n// TOKENIZER PROTOTYPES\nt_token\t\t*tokenizer(char *line);\nt_token\t\t*create_token(t_token_type type, char *value);\nvoid\t\tadd_token_back(t_token **list, t_token *new_token);\nt_token\t\t*get_operator_token(char *line, int *i);\nt_token\t\t*get_word_token(char *line, int *i);\n\n// PARSER PROTOTYPES\nt_command\t*parser(t_token *tokens);\nint\t\t\tsyntax_error_handler(char *token_value);\nt_command\t*create_command_node(void);\nvoid\t\tadd_command_node_back(t_command **list, t_command *new_cmd);\nt_redir\t\t*create_redir_node(t_token_type type, char *filename);\nvoid\t\tadd_redir_node_back(t_redir **list, t_redir *new_redir);\nint\t\t\thandle_redirection(t_command *cmd, t_token **current_token);\n\n// HEREDOC PROTOTYPES\nint\t\t\tprocess_heredoc_pipe(t_command *cmds_head, t_shell *shell);\n\n// EXPAND PROTOTYPES\nchar\t\t*expander(char *str, t_shell *shell, int *exp);\nvoid\t\tquote_remover(t_command *cmd_list);\nchar\t\t*strip_quotes(const char *str);\nvoid\t\tglobal_expand(t_command *cmds_head, t_shell *shell, int *exp);\nint\t\t\tmain_expand(t_command *cmds, t_shell *shell);\nchar\t\t*my_getenv(const char *name, char **env);\nvoid\t\tadd_arg_to_list(t_arg_list **head, char *arg_val);\nchar\t\t**convert_list_to_array(t_arg_list *head);\nvoid\t\tinit_data(t_exp_data **data_ptr, t_shell *shell, int *exp);\nint\t\t\tflag_redir_error(char *exp, char *org, int count);\n\n\n// TOOLS/STRINGS PROTOTYPES\nchar\t\t*ft_strdup(char *value);\nint\t\t\tft_strncmp(const char *s1, const char *s2, size_t n);\nint\t\t\tft_strcmp(const char *s1, const char *s2);\nsize_t\t\tft_strlen(const char *s);\nvoid\t\tft_putstr_fd(const char *s, int fd);\nchar\t\t*ft_substr(char const *s, unsigned int start, size_t len);\nchar\t\t*ft_strjoin(char const *s1, char const *s2);\nint\t\t\tft_isalpha(int c);\nint\t\t\tft_isalnum(int c);\nchar\t\t*ft_itoa(int n);\nvoid\t\texecutor(t_command *commands, t_shell *shell);\nchar\t\t**dupenv(char **envp);\nvoid\t\tfree_env(char **envp);\nint\t\t\tft_atoi(const char *str);\n\n\n// TOOLS/CHECKERS PROTOTYPES\nint\t\t\tft_isspace(char c);\nint\t\t\tis_metachar(char c);\nint\t\t\tdel_or_fnamesupported_metachar(char c);\nchar\t\t**ft_split(char const *s, char c);\nchar\t\t*ft_strchr(const char *s, int c);\n\n#endif\n\n",
  "EXECUTION/builtins_dispatch.c": "#include \"execution.h\"\n#include \"builtins/builtins.h\"\n\nint\tis_builtin(char *cmd)\n{\n\tif (!cmd)\n\t\treturn (0);\n\tif (ft_strcmp(cmd, \"echo\") == 0)\n\t\treturn (1);\n\tif (ft_strcmp(cmd, \"cd\") == 0)\n\t\treturn (1);\n\tif (ft_strcmp(cmd, \"pwd\") == 0)\n\t\treturn (1);\n\tif (ft_strcmp(cmd, \"export\") == 0)\n\t\treturn (1);\n\tif (ft_strcmp(cmd, \"unset\") == 0)\n\t\treturn (1);\n\tif (ft_strcmp(cmd, \"env\") == 0)\n\t\treturn (1);\n\tif (ft_strcmp(cmd, \"exit\") == 0)\n\t\treturn (1);\n\treturn (0);\n}\n\nint\tis_parent_builtin(char *cmd)\n{\n\tif (!cmd)\n\t\treturn (0);\n\tif (ft_strcmp(cmd, \"cd\") == 0)\n\t\treturn (1);\n\tif (ft_strcmp(cmd, \"export\") == 0)\n\t\treturn (1);\n\tif (ft_strcmp(cmd, \"unset\") == 0)\n\t\treturn (1);\n\tif (ft_strcmp(cmd, \"exit\") == 0)\n\t\treturn (1);\n\treturn (0);\n}\n\nvoid\texecute_builtin(t_command *cmd, t_shell *shell)\n{\n\tchar\t*cmd_name;\n\tint\t\tstatus;\n\n\tstatus = 0;\n\tif (!cmd || !cmd->args || !cmd->args[0])\n\t\treturn ;\n\tcmd_name = cmd->args[0];\n\tif (ft_strcmp(cmd_name, \"echo\") == 0)\n\t\tstatus = ft_echo(cmd->args);\n\telse if (ft_strcmp(cmd_name, \"cd\") == 0)\n\t\tstatus = ft_cd(cmd->args, shell);\n\telse if (ft_strcmp(cmd_name, \"pwd\") == 0)\n\t\tstatus = ft_pwd(shell);\n\telse if (ft_strcmp(cmd_name, \"export\") == 0)\n\t\tstatus = ft_export(cmd->args, shell);\n\telse if (ft_strcmp(cmd_name, \"unset\") == 0)\n\t\tstatus = ft_unset(cmd->args, shell);\n\telse if (ft_strcmp(cmd_name, \"env\") == 0)\n\t\tstatus = ft_env(shell);\n\telse if (ft_strcmp(cmd_name, \"exit\") == 0)\n\t\tstatus = ft_exit(cmd->args, shell);\n\tshell->last_exit_status = status;\n}",
  "EXECUTION/env_utils.c": "#include \"../parsing.h\"\n#include <stdlib.h>\n\nstatic int\tcount_env_vars(char **envp)\n{\n\tint\ti;\n\n\ti = 0;\n\tif (!envp)\n\t\treturn (0);\n\twhile (envp[i])\n\t\ti++;\n\treturn (i);\n}\n\nvoid\tfree_env(char **envp)\n{\n\tint\ti;\n\n\tif (!envp)\n\t\treturn ;\n\ti = 0;\n\twhile (envp[i])\n\t{\n\t\tfree(envp[i]);\n\t\ti++;\n\t}\n\tfree(envp);\n}\n\nchar\t**dupenv(char **envp)\n{\n\tint\t\ti;\n\tint\t\tcount;\n\tchar\t**new_envp;\n\n\tcount = count_env_vars(envp);\n\tnew_envp = (char **)malloc(sizeof(char *) * (count + 1));\n\tif (!new_envp)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (i < count)\n\t{\n\t\tnew_envp[i] = ft_strdup(envp[i]);\n\t\tif (!new_envp[i])\n\t\t{\n\t\t\twhile (--i >= 0)\n\t\t\t\tfree(new_envp[i]);\n\t\t\tfree(new_envp);\n\t\t\treturn (NULL);\n\t\t}\n\t\ti++;\n\t}\n\tnew_envp[i] = NULL;\n\treturn (new_envp);\n}\n\nchar\t*my_getenv(const char *name, char **env)\n{\n\tint\t\ti;\n\tsize_t\tname_len;\n\n\tif (!name || !env)\n\t\treturn (NULL);\n\tname_len = ft_strlen(name);\n\ti = 0;\n\twhile (env[i])\n\t{\n\t\tif (ft_strncmp(env[i], name, name_len) == 0)\n\t\t{\n\t\t\tif (env[i][name_len] == '=')\n\t\t\t\treturn (env[i] + name_len + 1);\n\t\t}\n\t\ti++;\n\t}\n\treturn (NULL);\n}\n\nint\tset_env(const char *name, const char *value, t_shell *shell)\n{\n\tint\t\ti;\n\tsize_t\tname_len;\n\tchar\t*new_var;\n\tchar\t*temp;\n\tchar\t**new_envp;\n\n\tname_len = ft_strlen(name);\n\ttemp = ft_strjoin(name, \"=\");\n\tnew_var = ft_strjoin(temp, value);\n\tfree(temp);\n\tif (!new_var)\n\t\treturn (1);\n\ti = 0;\n\twhile (shell->envp[i])\n\t{\n\t\tif (ft_strncmp(shell->envp[i], name, name_len) == 0 &&\n\t\t\tshell->envp[i][name_len] == '=')\n\t\t{\n\t\t\tfree(shell->envp[i]);\n\t\t\tshell->envp[i] = new_var;\n\t\t\treturn (0);\n\t\t}\n\t\ti++;\n\t}\n\tnew_envp = malloc(sizeof(char *) * (i + 2));\n\tif (!new_envp)\n\t{\n\t\tfree(new_var);\n\t\treturn (1);\n\t}\n\ti = -1;\n\twhile (shell->envp[++i])\n\t\tnew_envp[i] = shell->envp[i];\n\tnew_envp[i] = new_var;\n\tnew_envp[i + 1] = NULL;\n\tfree(shell->envp);\n\tshell->envp = new_envp;\n\treturn (0);\n}",
  "EXECUTION/execution.h": "#ifndef EXECUTION_H\n# define EXECUTION_H\n\n# include \"../parsing.h\"\n# include <fcntl.h>\n# include <sys/wait.h>\n# include <string.h>\n# include <errno.h>\n\nint\t\tset_env(const char *name, const char *value, t_shell *shell);\nint\t\thandle_redirections(t_command *cmd);\nvoid\trestore_fds(int original_stdin, int original_stdout);\nint\t\twait_for_children(pid_t last_pid);\nchar\t*find_path(char *cmd, char **envp);\nint\t\tis_builtin(char *cmd);\nvoid\texecute_builtin(t_command *cmd, t_shell *shell);\nint\t\tis_parent_builtin(char *cmd);\n\n#endif",
  "EXECUTION/executor.c": "#include \"execution.h\"\n\nstatic void\trun_child(t_command *cmd, t_shell *shell)\n{\n\tchar\t*path;\n\n\tsignal(SIGINT, SIG_DFL);\n\tsignal(SIGQUIT, SIG_DFL);\n\tif (handle_redirections(cmd) == -1)\n\t\texit(1);\n\tif (!cmd->args || !cmd->args[0])\n\t\texit(0);\n\tif (is_builtin(cmd->args[0]))\n\t{\n\t\texecute_builtin(cmd, shell);\n\t\texit(shell->last_exit_status);\n\t}\n\tpath = find_path(cmd->args[0], shell->envp);\n\tif (!path)\n\t\texit(127); // Command not found exit status\n\texecve(path, cmd->args, shell->envp);\n\tft_putstr_fd(\"minishell: \", 2);\n\tft_putstr_fd(cmd->args[0], 2);\n\tft_putstr_fd(\": \", 2);\n\tft_putstr_fd(strerror(errno), 2);\n\tft_putstr_fd(\"\\n\", 2);\n\tif (errno == EACCES)\n\t\texit(126); // Permission denied\n\texit(1); // General exec error\n}\n\nstatic void\texecute_single_command(t_command *cmd, t_shell *shell)\n{\n\tpid_t\tpid;\n\tint\t\toriginal_fds[2];\n\n\tif (cmd->args && cmd->args[0] && is_parent_builtin(cmd->args[0]))\n\t{\n\t\toriginal_fds[0] = dup(STDIN_FILENO);\n\t\toriginal_fds[1] = dup(STDOUT_FILENO);\n\t\tif (handle_redirections(cmd) == -1)\n\t\t{\n\t\t\tshell->last_exit_status = 1;\n\t\t\trestore_fds(original_fds[0], original_fds[1]);\n\t\t\treturn ;\n\t\t}\n\t\texecute_builtin(cmd, shell);\n\t\trestore_fds(original_fds[0], original_fds[1]);\n\t\treturn ;\n\t}\n\tpid = fork();\n\tif (pid == -1)\n\t{\n\t\tshell->last_exit_status = 1;\n\t\treturn ;\n\t}\n\tif (pid == 0)\n\t\trun_child(cmd, shell);\n\tshell->last_exit_status = wait_for_children(pid);\n}\n\nstatic void\tchild_process_pipeline(t_command *cmd, t_shell *shell,\n\tint in_fd, int *pipe_fd)\n{\n\n\tsignal(SIGINT, SIG_DFL);\n\tsignal(SIGQUIT, SIG_DFL);\n\tif (in_fd != STDIN_FILENO)\n\t{\n\t\tdup2(in_fd, STDIN_FILENO);\n\t\tclose(in_fd);\n\t}\n\tif (cmd->next_piped_command)\n\t{\n\t\tclose(pipe_fd[0]);\n\t\tdup2(pipe_fd[1], STDOUT_FILENO);\n\t\tclose(pipe_fd[1]);\n\t}\n\trun_child(cmd, shell);\n}\n\nstatic void\texecute_pipeline(t_command *cmd, t_shell *shell)\n{\n\tint\t\tpipe_fd[2];\n\tint\t\tin_fd;\n\tpid_t\tpid;\n\n\tin_fd = STDIN_FILENO;\n\twhile (cmd)\n\t{\n\t\tif (cmd->next_piped_command)\n\t\t\tif (pipe(pipe_fd) == -1)\n\t\t\t{\n\t\t\t\tshell->last_exit_status = 1;\n\t\t\t\treturn;\n\t\t\t}\n\t\tpid = fork();\n\t\tif (pid == -1)\n\t\t{\n\t\t\tshell->last_exit_status = 1;\n\t\t\treturn;\n\t\t}\n\t\tif (pid == 0)\n\t\t\tchild_process_pipeline(cmd, shell, in_fd, pipe_fd);\n\t\tif (in_fd != STDIN_FILENO)\n\t\t\tclose(in_fd);\n\t\tif (cmd->next_piped_command)\n\t\t{\n\t\t\tclose(pipe_fd[1]);\n\t\t\tin_fd = pipe_fd[0];\n\t\t}\n\t\tcmd = cmd->next_piped_command;\n\t}\n\tshell->last_exit_status = wait_for_children(pid);\n}\n\nvoid\texecutor(t_command *commands, t_shell *shell)\n{\n\tif (!commands)\n\t\treturn ;\n\tif (commands->next_piped_command)\n\t\texecute_pipeline(commands, shell);\n\telse\n\t\texecute_single_command(commands, shell);\n}\n",
  "EXECUTION/path_finder.c": "#include \"execution.h\"\nstatic int\tis_directory(const char *path)\n{\n\tint\t\tfd;\n\tchar\tbuffer;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd == -1)\n\t\treturn (0);\n\tif (read(fd, &buffer, 0) == -1 && errno == EISDIR)\n\t{\n\t\tclose(fd);\n\t\treturn (1);\n\t}\n\tclose(fd);\n\treturn (0);\n}\nstatic char\t*get_path_from_env(char **envp)\n{\n\tint\ti;\n\n\ti = 0;\n\twhile (envp && envp[i])\n\t{\n\t\tif (ft_strncmp(envp[i], \"PATH=\", 5) == 0)\n\t\t\treturn (envp[i] + 5);\n\t\ti++;\n\t}\n\treturn (NULL);\n}\n\nstatic char\t*check_paths(char *cmd, char **paths)\n{\n\tint\t\ti;\n\tchar\t*path_part;\n\tchar\t*full_path;\n\n\ti = 0;\n\twhile (paths[i])\n\t{\n\t\tpath_part = gc_strjoin(paths[i], \"/\");\n\t\tfull_path = gc_strjoin(path_part, cmd);\n\t\tif (access(full_path, X_OK) == 0)\n\t\t\treturn (full_path);\n\t\ti++;\n\t}\n\tft_putstr_fd(\"minishell: \", 2);\n\tft_putstr_fd(cmd, 2);\n\tft_putstr_fd(\": command not found\\n\", 2);\n\treturn (NULL);\n}\n\nstatic char\t*check_absolute_path(char *cmd)\n{\n\n\tif (is_directory(cmd))\n\t{\n\t\tft_putstr_fd(\"minishell: \", 2);\n\t\tft_putstr_fd(cmd, 2);\n\t\tft_putstr_fd(\": is a directory\\n\", 2);\n\t\treturn (NULL);\n\t}\n\tif (access(cmd, X_OK) == 0)\n\t\treturn (gc_strdup(cmd));\n\tft_putstr_fd(\"minishell: \", 2);\n\tperror(cmd);\n\treturn (NULL);\n}\n\nchar\t*find_path(char *cmd, char **envp)\n{\n\tchar\t**paths;\n\tchar\t*path_env;\n\n\tif (!cmd || *cmd == '\\0')\n\t{\n\t\tft_putstr_fd(\"minishell: : command not found\\n\", 2);\n\t\treturn (NULL);\n\t}\n\tif (ft_strchr(cmd, '/'))\n\t\treturn (check_absolute_path(cmd));\n\tpath_env = get_path_from_env(envp);\n\tif (!path_env)\n\t{\n\t\tft_putstr_fd(\"minishell: \", 2);\n\t\tft_putstr_fd(cmd, 2);\n\t\tft_putstr_fd(\": No such file or directory\\n\", 2);\n\t\treturn (NULL);\n\t}\n\tpaths = ft_split(path_env, ':');\n\treturn (check_paths(cmd, paths));\n}\n",
  "EXECUTION/redirections.c": "#include \"execution.h\"\n\nstatic int\thandle_input_redir(t_redir *redir)\n{\n\tint\tfd;\n\t\n\tif (redir->type == REDIR_INPUT)\n\t{\n\t\tfd = open(redir->del_or_fname, O_RDONLY);\n\t\tif (fd == -1)\n\t\t{\n\t\t\tft_putstr_fd(\"minishell: \", 2);\n\t\t\tperror(redir->del_or_fname);\n\t\t\treturn (-1);\n\t\t}\n\t\tdup2(fd, STDIN_FILENO);\n\t\tclose(fd);\n\t}\n\telse\n\t{\n\t\tdup2(redir->heredoc_fd, STDIN_FILENO);\n\t\tclose(redir->heredoc_fd);\n\t}\n\treturn (0);\n}\n\nstatic int\thandle_output_redir(t_redir *redir)\n{\n\tint\tfd;\n\n\tif (redir->type == REDIR_OUTPUT_TRUNC)\n\t\tfd = open(redir->del_or_fname,\n\t\t\t\tO_WRONLY | O_CREAT | O_TRUNC, 0644);\n\telse\n\t\tfd = open(redir->del_or_fname,\n\t\t\t\tO_WRONLY | O_CREAT | O_APPEND, 0644);\n\tif (fd == -1)\n\t{\n\t\tft_putstr_fd(\"minishell: \", 2);\n\t\tperror(redir->del_or_fname);\n\t\treturn (-1);\n\t}\n\tdup2(fd, STDOUT_FILENO);\n\tclose(fd);\n\treturn (0);\n}\n\nint\thandle_redirections(t_command *cmd)\n{\n\tt_redir\t*redir;\n\n\tredir = cmd->redirections;\n\twhile (redir)\n\t{\n\t\tif (redir->type == REDIR_INPUT || redir->type == REDIR_HEREDOC)\n\t\t{\n\t\t\tif (handle_input_redir(redir) == -1)\n\t\t\t\treturn (-1);\n\t\t}\n\t\telse if (redir->type == REDIR_OUTPUT_TRUNC\n\t\t\t|| redir->type == REDIR_OUTPUT_APPEND)\n\t\t{\n\t\t\tif (handle_output_redir(redir) == -1)\n\t\t\t\treturn (-1);\n\t\t}\n\t\tredir = redir->next;\n\t}\n\treturn (0);\n}\n\nvoid\trestore_fds(int original_stdin, int original_stdout)\n{\n\tdup2(original_stdin, STDIN_FILENO);\n\tdup2(original_stdout, STDOUT_FILENO);\n\tclose(original_stdin);\n\tclose(original_stdout);\n}\n\nint\twait_for_children(pid_t last_pid)\n{\n\tint\tstatus;\n\tint\texit_status;\n\tint\tpid;\n\n\tif (last_pid == -1)\n\t\treturn (1);\n\texit_status = 1;\n\twaitpid(last_pid, &status, 0);\n\tif (WIFEXITED(status))\n\t\texit_status = WEXITSTATUS(status);\n\telse if (WIFSIGNALED(status))\n\t{\n\t\texit_status = 128 + WTERMSIG(status);\n\t\tif (WTERMSIG(status) == SIGINT)\n\t\t\tft_putstr_fd(\"\\n\", 2);\n\t}\n\tpid = 0;\n\twhile (pid != -1)\n\t\tpid = wait(NULL);\n\treturn (exit_status);\n}\n",
  "EXECUTION/builtins/builtins.h": "#ifndef BUILTINS_H\n# define BUILTINS_H\n\n# include \"../execution.h\"\n\nint\t\tft_cd(char **args, t_shell *shell);\nint\t\tft_echo(char **args);\nint\t\tft_env(t_shell *shell);\nint\t\tft_exit(char **args, t_shell *shell);\nint\t\tft_export(char **args, t_shell *shell);\nint\t\tft_pwd(t_shell *shell);\nint\t\tft_unset(char **args, t_shell *shell);\n\n#endif",
  "EXECUTION/builtins/ft_cd.c": "#include \"builtins.h\"\n#include <unistd.h>\n#include <stdio.h>\n\nstatic int\tupdate_pwd_in_env(t_shell *shell)\n{\n\tchar\tcwd_buffer[1024];\n\tchar\t*old_pwd_val;\n\n\told_pwd_val = my_getenv(\"PWD\", shell->envp);\n\tif (old_pwd_val)\n\t\tset_env(\"OLDPWD\", old_pwd_val, shell);\n\tif (getcwd(cwd_buffer, sizeof(cwd_buffer)) != NULL)\n\t{\n\t\treturn (set_env(\"PWD\", cwd_buffer, shell));\n\t}\n\tperror(\"minishell: cd: getcwd\");\n\treturn (1);\n}\n\nint\tft_cd(char **args, t_shell *shell)\n{\n\tchar\t*path;\n\tchar\t*old_pwd_path;\n\n\tif (args[1] && args[2])\n\t{\n\t\tft_putstr_fd(\"minishell: cd: too many arguments\\n\", 2);\n\t\treturn (1);\n\t}\n\tpath = args[1];\n\tif (!path)\n\t{\n\t\tpath = my_getenv(\"HOME\", shell->envp);\n\t\tif (!path)\n\t\t{\n\t\t\tft_putstr_fd(\"minishell: cd: HOME not set\\n\", 2);\n\t\t\treturn (1);\n\t\t}\n\t}\n\telse if (ft_strcmp(path, \"-\") == 0)\n\t{\n\t\told_pwd_path = my_getenv(\"OLDPWD\", shell->envp);\n\t\tif (!old_pwd_path)\n\t\t{\n\t\t\tft_putstr_fd(\"minishell: cd: OLDPWD not set\\n\", 2);\n\t\t\treturn (1);\n\t\t}\n\t\tpath = old_pwd_path;\n\t\tft_putstr_fd(path, 1);\n\t\tft_putstr_fd(\"\\n\", 1);\n\t}\n\tif (chdir(path) != 0)\n\t{\n\t\tft_putstr_fd(\"minishell: cd: \", 2);\n\t\tperror(path);\n\t\treturn (1);\n\t}\n\tupdate_pwd_in_env(shell);\n\treturn (0);\n}",
  "EXECUTION/builtins/ft_echo.c": "#include \"builtins.h\"\n\nstatic int\tcheck_n_option(char *arg)\n{\n\tint\ti;\n\n\tif (!arg || arg[0] != '-')\n\t\treturn (0);\n\ti = 1;\n\twhile (arg[i] == 'n')\n\t\ti++;\n\tif (arg[i] == '\\0')\n\t\treturn (1);\n\treturn (0);\n}\n\nint\tft_echo(char **args)\n{\n\tint\ti;\n\tint\tnewline_flag;\n\n\ti = 1;\n\tnewline_flag = 1;\n\twhile (args[i] && check_n_option(args[i]))\n\t{\n\t\tnewline_flag = 0;\n\t\ti++;\n\t}\n\twhile (args[i])\n\t{\n\t\tft_putstr_fd(args[i], 1);\n\t\tif (args[i + 1])\n\t\t\tft_putstr_fd(\" \", 1);\n\t\ti++;\n\t}\n\tif (newline_flag)\n\t\tft_putstr_fd(\"\\n\", 1);\n\treturn (0);\n}\n",
  "EXECUTION/builtins/ft_env.c": "#include \"builtins.h\"\n\nint\tft_env(t_shell *shell)\n{\n\tint\ti;\n\n\ti = 0;\n\tif (!shell->envp)\n\t\treturn (0);\n\twhile (shell->envp[i])\n\t{\n\t\tft_putstr_fd(shell->envp[i], 1);\n\t\tft_putstr_fd(\"\\n\", 1);\n\t\ti++;\n\t}\n\treturn (0);\n}\n",
  "EXECUTION/builtins/ft_exit.c": "#include \"builtins.h\"\n\nint\tft_exit(char **args, t_shell *shell)\n{\n\tft_putstr_fd(\"exit\\n\", 1);\n\tif (args[1] && args[2])\n\t{\n\t\tft_putstr_fd(\"minishell: exit: too many arguments\\n\", 2);\n\t\treturn (1);\n\t}\n\tif (args[1])\n\t{\n\t\t// Note: A proper implementation would check if args[1] is numeric.\n\t\t// This is a simplified version for the refactor.\n\t\texit(ft_atoi(args[1]));\n\t}\n\texit(shell->last_exit_status);\n\treturn (0); // This line is never reached\n}\n",
  "EXECUTION/builtins/ft_export.c": "#include \"builtins.h\"\n\nstatic int\tprint_exported_vars(char **envp)\n{\n\tint\t\ti;\n\tchar\t*equal_sign;\n\tint\t\tname_len;\n\n\ti = 0;\n\twhile (envp && envp[i])\n\t{\n\t\tft_putstr_fd(\"declare -x \", 1);\n\t\tequal_sign = ft_strchr(envp[i], '=');\n\t\tif (equal_sign)\n\t\t{\n\t\t\tname_len = equal_sign - envp[i];\n\t\t\twrite(1, envp[i], name_len);\n\t\t\tft_putstr_fd(\"=\\\"\", 1);\n\t\t\tft_putstr_fd(equal_sign + 1, 1);\n\t\t\tft_putstr_fd(\"\\\"\", 1);\n\t\t}\n\t\telse\n\t\t\tft_putstr_fd(envp[i], 1);\n\t\tft_putstr_fd(\"\\n\", 1);\n\t\ti++;\n\t}\n\treturn (0);\n}\n\nstatic int\tadd_or_update_env(char *arg, char ***envp_ptr)\n{\n\tint\t\ti;\n\tint\t\tcount;\n\tchar\t**new_envp;\n\tsize_t\tlen;\n\n\tlen = 0;\n\twhile (arg[len] && arg[len] != '=')\n\t\tlen++;\n\ti = 0;\n\twhile ((*envp_ptr)[i]\n\t\t&& (ft_strncmp((*envp_ptr)[i], arg, len) || (*envp_ptr)[i][len] != '='))\n\t\ti++;\n\tif ((*envp_ptr)[i])\n\t{\n\t\tfree((*envp_ptr)[i]);\n\t\t(*envp_ptr)[i] = ft_strdup(arg);\n\t\tif (!(*envp_ptr)[i])\n\t\t\treturn (1);\n\t}\n\telse\n\t{\n\t\tcount = 0;\n\t\twhile ((*envp_ptr)[count])\n\t\t\tcount++;\n\t\tnew_envp = malloc(sizeof(char *) * (count + 2));\n\t\tif (!new_envp)\n\t\t\treturn (1);\n\t\ti = -1;\n\t\twhile (++i < count)\n\t\t\tnew_envp[i] = (*envp_ptr)[i];\n\t\tnew_envp[i] = ft_strdup(arg);\n\t\tif (!new_envp[i])\n\t\t{\n\t\t\tfree(new_envp);\n\t\t\treturn (1);\n\t\t}\n\t\tnew_envp[i + 1] = NULL;\n\t\tfree(*envp_ptr);\n\t\t*envp_ptr = new_envp;\n\t}\n\treturn (0);\n}\n\nint\tft_export(char **args, t_shell *shell)\n{\n\tint\ti;\n\tint\tstatus;\n\n\ti = 1;\n\tstatus = 0;\n\tif (!args[1])\n\t\treturn (print_exported_vars(shell->envp));\n\twhile (args[i])\n\t{\n\t\tif (!ft_strchr(args[i], '='))\n\t\t{\n\t\t\ti++;\n\t\t\tcontinue ;\n\t\t}\n\t\tif (add_or_update_env(args[i], &shell->envp) != 0)\n\t\t{\n\t\t\tft_putstr_fd(\"minishell: export: allocation error\\n\", 2);\n\t\t\tstatus = 1;\n\t\t}\n\t\ti++;\n\t}\n\treturn (status);\n}",
  "EXECUTION/builtins/ft_pwd.c": "#include \"builtins.h\"\n\nint\tft_pwd(t_shell *shell)\n{\n\tchar\t*pwd_val;\n\n\tpwd_val = my_getenv(\"PWD\", shell->envp);\n\tif (pwd_val)\n\t{\n\t\tft_putstr_fd(pwd_val, 1);\n\t\tft_putstr_fd(\"\\n\", 1);\n\t\treturn (0);\n\t}\n\tft_putstr_fd(\"minishell: pwd: PWD not set\\n\", 2);\n\treturn (1);\n}",
  "EXECUTION/builtins/ft_unset.c": "#include \"builtins.h\"\n\nstatic int\tcount_vars(char **envp)\n{\n\tint\ti;\n\n\ti = 0;\n\twhile (envp && envp[i])\n\t\ti++;\n\treturn (i);\n}\n\nstatic int\tremove_env_var(char *var_to_unset, char ***envp_ptr)\n{\n\tint\t\ti;\n\tint\t\tj;\n\tint\t\tcount;\n\tchar\t**new_envp;\n\tsize_t\tlen;\n\n\tlen = ft_strlen(var_to_unset);\n\tcount = count_vars(*envp_ptr);\n\tnew_envp = malloc(sizeof(char *) * (count + 1));\n\tif (!new_envp)\n\t\treturn (1);\n\ti = 0;\n\tj = 0;\n\twhile (i < count)\n\t{\n\t\tif (ft_strncmp((*envp_ptr)[i], var_to_unset, len) == 0\n\t\t\t&& ((*envp_ptr)[i][len] == '=' || (*envp_ptr)[i][len] == '\\0'))\n\t\t\tfree((*envp_ptr)[i]);\n\t\telse\n\t\t\tnew_envp[j++] = (*envp_ptr)[i];\n\t\ti++;\n\t}\n\tnew_envp[j] = NULL;\n\tfree(*envp_ptr);\n\t*envp_ptr = new_envp;\n\treturn (0);\n}\n\nint\tft_unset(char **args, t_shell *shell)\n{\n\tint\ti;\n\n\ti = 1;\n\twhile (args[i])\n\t{\n\t\tremove_env_var(args[i], &shell->envp);\n\t\ti++;\n\t}\n\treturn (0);\n}",
  "EXPAND/expand.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   expand.c                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/11 23:34:49 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/14 17:54:31 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n#include <stdlib.h>\n\nstatic void\tappend_char(char **s, char c)\n{\n\tchar\tto_append[2];\n\n\tto_append[0] = c;\n\tto_append[1] = '\\0';\n\t*s = gc_strjoin(*s, to_append);\n}\n\nstatic char\t*extract_variable_name(const char *str)\n{\n\tint\ti;\n\n\ti = 0;\n\tif (ft_isalpha(str[i]) || str[i] == '_')\n\t{\n\t\ti++;\n\t\twhile (ft_isalnum(str[i]) || str[i] == '_')\n\t\t\ti++;\n\t}\n\treturn (gc_substr(str, 0, i));\n}\n\nstatic void\thandle_dollar_expansion(char **new_str, const char *str,\n\t\tt_exp_data *data, int *i)\n{\n\tchar\t*key;\n\tchar\t*value;\n\n\t(*i)++;\n\tif (str[*i] == '?')\n\t{\n\t\t*new_str = gc_strjoin(*new_str, gc_itoa(data->shell->last_exit_status));\n\t\t(*i)++;\n\t\treturn ;\n\t}\n\tkey = extract_variable_name(&str[*i]);\n\tif (!key || *key == '\\0')\n\t{\n\t\tappend_char(new_str, '$');\n\t\treturn ;\n\t}\n\tvalue = my_getenv(key, data->shell->envp);\n\tif (value)\n\t\t*new_str = gc_strjoin(*new_str, value);\n\t*i += ft_strlen(key);\n\tif (value)\n\t\t*(data->flag) = 1;\n}\n\nchar\t*expander(char *str, t_shell *shell, int *exp)\n{\n\tchar\t\t*new_str;\n\tint\t\t\ti;\n\tbool\t\tin_dquote;\n\tbool\t\tin_squote;\n\tt_exp_data\t*data;\n\n\tif (!str)\n\t\treturn (NULL);\n\tnew_str = gc_strdup(\"\");\n\ti = 0;\n\tin_dquote = false;\n\tin_squote = false;\n\tinit_data(&data, shell, exp);\n\twhile (str[i])\n\t{\n\t\tif (str[i] == '\\'' && !in_dquote)\n\t\t\tin_squote = !in_squote;\n\t\telse if (str[i] == '\\\"' && !in_squote)\n\t\t\tin_dquote = !in_dquote;\n\t\tif (str[i] == '$' && !in_squote)\n\t\t\thandle_dollar_expansion(&new_str, str, data, &i);\n\t\telse\n\t\t\t(append_char(&new_str, str[i]), i++);\n\t}\n\treturn (new_str);\n}\n",
  "EXPAND/g_expand.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   g_expand.c                                         :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/13 05:41:03 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/14 15:12:23 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nstatic int\tprocess_single_redir(t_redir *redir, t_shell *shell, int *ex)\n{\n\tchar\t*original_str;\n\tchar\t*exp_str;\n\tchar\t**split_words;\n\tint\t\tword_count;\n\n\toriginal_str = redir->del_or_fname;\n\texp_str = expander(original_str, shell, ex);\n\tif (((*ex) && !ft_strchr(original_str, '\\\"')\n\t\t\t&& !ft_strchr(original_str, '\\'')) || (ft_strlen(exp_str) == 0)\n\t\t|| ft_strchr(exp_str, '$'))\n\t{\n\t\tsplit_words = ft_split(exp_str, ' ');\n\t\tword_count = 0;\n\t\twhile (split_words && split_words[word_count])\n\t\t\tword_count++;\n\t\tflag_redir_error(exp_str, original_str, word_count);\n\t\tredir->del_or_fname = split_words[0];\n\t}\n\telse\n\t\tredir->del_or_fname = exp_str;\n\treturn (1);\n}\n\nstatic void\texpand_and_split_arg(char *arg, t_shell *shell, t_arg_list **head)\n{\n\tint\t\thas_expanded;\n\tchar\t*exp_str;\n\tchar\t**split_words;\n\tint\t\tj;\n\n\thas_expanded = 0;\n\texp_str = expander(arg, shell, &has_expanded);\n\tif ((has_expanded && !ft_strchr(arg, '\\\"') && !ft_strchr(arg, '\\''))\n\t\t|| (ft_strlen(exp_str) == 0))\n\t{\n\t\tsplit_words = ft_split(exp_str, ' ');\n\t\tj = 0;\n\t\twhile (split_words && split_words[j])\n\t\t\tadd_arg_to_list(head, split_words[j++]);\n\t}\n\telse\n\t\tadd_arg_to_list(head, exp_str);\n}\n\nstatic int\texpand_and_check_redirs(t_command *cmd, t_shell *shell)\n{\n\tt_redir\t*redir;\n\tint\t\tex;\n\n\tredir = cmd->redirections;\n\tex = 0;\n\twhile (redir)\n\t{\n\t\tif (redir->type != REDIR_HEREDOC)\n\t\t{\n\t\t\tif (!process_single_redir(redir, shell, &ex))\n\t\t\t\treturn (0);\n\t\t}\n\t\tredir = redir->next;\n\t}\n\treturn (1);\n}\n\nstatic void\trebuild_args_with_splitting(t_command *cmd, t_shell *shell)\n{\n\tt_arg_list\t*arg_head;\n\tint\t\t\ti;\n\n\tif (!cmd->args)\n\t\treturn ;\n\targ_head = NULL;\n\ti = 0;\n\twhile (cmd->args[i])\n\t{\n\t\texpand_and_split_arg(cmd->args[i], shell, &arg_head);\n\t\ti++;\n\t}\n\tcmd->args = convert_list_to_array(arg_head);\n}\n\nint\tmain_expand(t_command *cmds, t_shell *shell)\n{\n\tt_command\t*cmd;\n\n\tif (!cmds)\n\t\treturn (1);\n\tcmd = cmds;\n\twhile (cmd)\n\t{\n\t\tif (!expand_and_check_redirs(cmd, shell))\n\t\t\treturn (0);\n\t\trebuild_args_with_splitting(cmd, shell);\n\t\tcmd = cmd->next_piped_command;\n\t}\n\treturn (1);\n}\n",
  "EXPAND/helper.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   helper.c                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/14 10:57:02 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/14 19:38:52 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nint\tflag_redir_error(char *exp, char *org, int count)\n{\n\tif (ft_strchr(exp, '$') && (count == 1))\n\t\treturn (ft_putstr_fd(\"minishell: : No such file or directory\\n\", 2), 0);\n\tif (count != 1)\n\t{\n\t\t(ft_putstr_fd(\"minishell: \", 2), ft_putstr_fd(org, 2));\n\t\treturn (ft_putstr_fd(\": ambiguous redirect\\n\", 2), 0);\n\t}\n\treturn (1);\n}\n\nvoid\tadd_arg_to_list(t_arg_list **head, char *arg_val)\n{\n\tt_arg_list\t*new_node;\n\tt_arg_list\t*current;\n\n\tnew_node = gc_mall(sizeof(t_arg_list));\n\tnew_node->arg = arg_val;\n\tnew_node->next = NULL;\n\tif (!*head)\n\t{\n\t\t*head = new_node;\n\t\treturn ;\n\t}\n\tcurrent = *head;\n\twhile (current->next)\n\t\tcurrent = current->next;\n\tcurrent->next = new_node;\n}\n\nchar\t**convert_list_to_array(t_arg_list *head)\n{\n\tint\t\t\tcount;\n\tt_arg_list\t*current;\n\tchar\t\t**array;\n\tint\t\t\ti;\n\n\tcount = 0;\n\tcurrent = head;\n\twhile (current)\n\t{\n\t\tcount++;\n\t\tcurrent = current->next;\n\t}\n\tarray = gc_mall(sizeof(char *) * (count + 1));\n\tcurrent = head;\n\ti = 0;\n\twhile (current)\n\t{\n\t\tarray[i++] = current->arg;\n\t\tcurrent = current->next;\n\t}\n\tarray[i] = NULL;\n\treturn (array);\n}\n\nvoid\tinit_data(t_exp_data **data_ptr, t_shell *shell, int *exp)\n{\n\t*data_ptr = gc_mall(sizeof(t_exp_data));\n\tif (!(*data_ptr))\n\t\treturn ;\n\t(*data_ptr)->shell = shell;\n\t(*data_ptr)->flag = exp;\n\t(*data_ptr)->next = NULL;\n}\n",
  "EXPAND/quotes_removal.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   quotes_removal.c                                   :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/11 23:37:45 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/11 23:37:45 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nstatic void\tclean_quotes_in_args(t_command *cmd)\n{\n\tint\t\ti;\n\tchar\t*stripped;\n\n\ti = 0;\n\tif (!cmd || !cmd->args)\n\t\treturn ;\n\twhile (cmd->args[i])\n\t{\n\t\tstripped = strip_quotes(cmd->args[i]);\n\t\tif (stripped)\n\t\t\tcmd->args[i] = stripped;\n\t\ti++;\n\t}\n}\n\nstatic void\tclean_quotes_in_redirs(t_command *cmd)\n{\n\tt_redir\t*redir;\n\tchar\t*stripped;\n\n\tif (!cmd)\n\t\treturn ;\n\tredir = cmd->redirections;\n\twhile (redir)\n\t{\n\t\tif (redir->type != REDIR_HEREDOC)\n\t\t{\n\t\t\tstripped = strip_quotes(redir->del_or_fname);\n\t\t\tif (stripped)\n\t\t\t\tredir->del_or_fname = stripped;\n\t\t}\n\t\tredir = redir->next;\n\t}\n}\n\nvoid\tquote_remover(t_command *cmd_list)\n{\n\twhile (cmd_list)\n\t{\n\t\tclean_quotes_in_args(cmd_list);\n\t\tclean_quotes_in_redirs(cmd_list);\n\t\tcmd_list = cmd_list->next_piped_command;\n\t}\n}\n",
  "EXPAND/utils.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   utils.c                                            :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/13 23:15:34 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/13 23:15:34 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\" \n\nstatic size_t\tcount_stripped_len(const char *str)\n{\n\tsize_t\ti;\n\tsize_t\tlen;\n\tbool\tin_squote;\n\tbool\tin_dquote;\n\n\ti = 0;\n\tlen = 0;\n\tin_squote = false;\n\tin_dquote = false;\n\twhile (str[i])\n\t{\n\t\tif (str[i] == '\\'' && !in_dquote)\n\t\t\tin_squote = !in_squote;\n\t\telse if (str[i] == '\\\"' && !in_squote)\n\t\t\tin_dquote = !in_dquote;\n\t\telse\n\t\t\tlen++;\n\t\ti++;\n\t}\n\treturn (len);\n}\n\nstatic void\tperform_strip_loop(const char *str, char *cleaned)\n{\n\tsize_t\ti;\n\tsize_t\tj;\n\tbool\tin_squote;\n\tbool\tin_dquote;\n\n\ti = 0;\n\tj = 0;\n\tin_squote = false;\n\tin_dquote = false;\n\twhile (str[i])\n\t{\n\t\tif (str[i] == '\\'' && !in_dquote)\n\t\t\tin_squote = !in_squote;\n\t\telse if (str[i] == '\\\"' && !in_squote)\n\t\t\tin_dquote = !in_dquote;\n\t\telse\n\t\t\tcleaned[j++] = str[i];\n\t\ti++;\n\t}\n\tcleaned[j] = '\\0';\n}\n\nchar\t*strip_quotes(const char *str)\n{\n\tchar\t*cleaned;\n\n\tif (!str)\n\t\treturn (NULL);\n\tcleaned = gc_mall(count_stripped_len(str) + 1);\n\tif (!cleaned)\n\t\treturn (NULL);\n\tperform_strip_loop(str, cleaned);\n\treturn (cleaned);\n}\n",
  "GARBAGE_COLLECTOR/gc_mall.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   gc_mall.c                                          :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/14 15:43:16 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/14 15:43:16 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../parsing.h\"\n\nstatic t_gc_node\t**get_gc_head_instance(void)\n{\n\tstatic t_gc_node\t*head;\n\n\treturn (&head);\n}\n\nvoid\tgc_add_pt(void *pt)\n{\n\tt_gc_node\t*new_node;\n\tt_gc_node\t**head;\n\n\tif (!pt)\n\t\treturn ;\n\thead = get_gc_head_instance();\n\tnew_node = (t_gc_node *)malloc(sizeof(t_gc_node));\n\tif (!new_node)\n\t{\n\t\tperror(\"malloc failed in garbage collector\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tnew_node->pt = pt;\n\tnew_node->next = *head;\n\t*head = new_node;\n}\n\nchar\t*gc_strdup(char *str)\n{\n\tchar\t*new_str;\n\n\tif (!str)\n\t\treturn (NULL);\n\tnew_str = ft_strdup(str);\n\tif (!new_str)\n\t{\n\t\tperror(\"strdup failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(new_str);\n\treturn (new_str);\n}\n\nchar\t*gc_substr(char const *s, unsigned int start, size_t len)\n{\n\tchar\t*new_str;\n\n\tif (!s)\n\t\treturn (NULL);\n\tnew_str = ft_substr(s, start, len);\n\tif (!new_str)\n\t{\n\t\tperror(\"substr failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(new_str);\n\treturn (new_str);\n}\n\nvoid\tgc_freed(void)\n{\n\tt_gc_node\t*current;\n\tt_gc_node\t*tmp;\n\tt_gc_node\t**head;\n\n\thead = get_gc_head_instance();\n\tcurrent = *head;\n\twhile (current != NULL)\n\t{\n\t\ttmp = current;\n\t\tcurrent = current->next;\n\t\tfree(tmp->pt);\n\t\tfree(tmp);\n\t}\n\t*head = NULL;\n}\n",
  "GARBAGE_COLLECTOR/gc_mall2.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   gc_mall2.c                                         :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/14 15:45:12 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/14 20:58:00 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nchar\t*gc_itoa(int n)\n{\n\tchar\t*new_str;\n\n\tnew_str = ft_itoa(n);\n\tif (!new_str)\n\t{\n\t\tperror(\"substr failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(new_str);\n\treturn (new_str);\n}\n\nvoid\t*gc_mall(size_t size)\n{\n\tvoid\t*pt;\n\n\tpt = malloc(size);\n\tif (!pt)\n\t{\n\t\tperror(\"malloc failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(pt);\n\treturn (pt);\n}\n\nchar\t*gc_strjoin(char const *s1, char const *s2)\n{\n\tchar\t*new_str;\n\n\tif (!s1 || !s2)\n\t\treturn (NULL);\n\tnew_str = ft_strjoin(s1, s2);\n\tif (!new_str)\n\t{\n\t\tperror(\"substr failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(new_str);\n\treturn (new_str);\n}\n",
  "HEREDOC/processor.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   processor.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/11 23:17:17 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/12 23:38:40 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nstatic char\t*maybe_expand_line(char *line, bool flag, t_shell *shell)\n{\n\tif (flag)\n\t\treturn (expander(line, shell, 0));\n\telse\n\t\treturn (gc_strdup(line));\n}\n\nstatic int\thandle_single_heredoc(t_redir *redir, t_shell *shell)\n{\n\tint\t\tfd[2];\n\tchar\t*line;\n\tchar\t*processed_line;\n\tchar\t*delimiter;\n\n\tif (pipe(fd) == -1)\n\t\treturn (perror(\"pipe\"), 0);\n\tdelimiter = strip_quotes(redir->del_or_fname);\n\twhile (1)\n\t{\n\t\tline = readline(\"heredoc> \");\n\t\tif (!line || ft_strcmp(line, delimiter) == 0)\n\t\t{\n\t\t\tif (line)\n\t\t\t\tfree(line);\n\t\t\tbreak ;\n\t\t}\n\t\tprocessed_line = maybe_expand_line(line,\n\t\t\t\tredir->expand_in_heredoc, shell);\n\t\twrite(fd[1], processed_line, ft_strlen(processed_line));\n\t\t(write(fd[1], \"\\n\", 1), free(line));\n\t}\n\tclose(fd[1]);\n\tredir->heredoc_fd = fd[0];\n\treturn (1);\n}\n\nint\tprocess_heredoc_pipe(t_command *cmds_head, t_shell *shell)\n{\n\tt_command\t*cmd;\n\tt_redir\t\t*redir;\n\n\tcmd = cmds_head;\n\twhile (cmd)\n\t{\n\t\tredir = cmd->redirections;\n\t\twhile (redir)\n\t\t{\n\t\t\tif (redir->type == REDIR_HEREDOC)\n\t\t\t{\n\t\t\t\tif (!handle_single_heredoc(redir, shell))\n\t\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tredir = redir->next;\n\t\t}\n\t\tcmd = cmd->next_piped_command;\n\t}\n\treturn (1);\n}\n",
  "PARSER/error_handler.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   error_handler.c                                    :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/11 23:14:18 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/11 23:14:18 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nint\tsyntax_error_handler(char *token_value)\n{\n\tft_putstr_fd(\"minishell: syntax error near unexpected token `\", 2);\n\tif (token_value)\n\t\tft_putstr_fd(token_value, 2);\n\telse\n\t\tft_putstr_fd(\"newline\", 2);\n\tft_putstr_fd(\"'\\n\", 2);\n\treturn (0);\n}\n",
  "PARSER/processor.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   processor.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/11 23:13:35 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/11 23:13:35 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nstatic int\tcount_args_in_segment(t_token *tokens)\n{\n\tint\tcount;\n\n\tcount = 0;\n\twhile (tokens && tokens->type != TOKEN_PIPE && tokens->type != TOKEN_EOF)\n\t{\n\t\tif (tokens->type == TOKEN_WORD)\n\t\t\tcount++;\n\t\telse if (tokens->type >= TOKEN_REDIR_IN)\n\t\t\ttokens = tokens->next;\n\t\tif (tokens)\n\t\t\ttokens = tokens->next;\n\t}\n\treturn (count);\n}\n\nstatic int\tprocess_cmds(t_command **command_list, t_token **tokens)\n{\n\tt_command\t*current_cmd;\n\tint\t\t\ti;\n\n\tcurrent_cmd = create_command_node();\n\tadd_command_node_back(command_list, current_cmd);\n\tcurrent_cmd->args = gc_mall(sizeof(char *)\n\t\t\t* (count_args_in_segment(*tokens) + 1));\n\ti = 0;\n\twhile (*tokens && (*tokens)->type != TOKEN_PIPE\n\t\t&& (*tokens)->type != TOKEN_EOF)\n\t{\n\t\tif ((*tokens)->type == TOKEN_WORD)\n\t\t{\n\t\t\tcurrent_cmd->args[i++] = gc_strdup((*tokens)->value);\n\t\t\t*tokens = (*tokens)->next;\n\t\t}\n\t\telse if ((*tokens)->type >= TOKEN_REDIR_IN)\n\t\t{\n\t\t\tif (!handle_redirection(current_cmd, tokens))\n\t\t\t\treturn (0);\n\t\t}\n\t}\n\tcurrent_cmd->args[i] = NULL;\n\treturn (1);\n}\n\nt_command\t*parser(t_token *tokens)\n{\n\tt_command\t*command_list;\n\n\tif (!tokens || tokens->type == TOKEN_EOF)\n\t\treturn (NULL);\n\tcommand_list = NULL;\n\twhile (tokens && tokens->type != TOKEN_EOF)\n\t{\n\t\tif (tokens->type == TOKEN_PIPE)\n\t\t\treturn (syntax_error_handler(tokens->value), NULL);\n\t\tif (!process_cmds(&command_list, &tokens))\n\t\t\treturn (NULL);\n\t\tif (tokens && tokens->type == TOKEN_PIPE)\n\t\t{\n\t\t\ttokens = tokens->next;\n\t\t\tif (!tokens || tokens->type == TOKEN_EOF)\n\t\t\t\treturn (syntax_error_handler(\"newline\"), NULL);\n\t\t}\n\t}\n\treturn (command_list);\n}\n",
  "PARSER/redirections.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   redirections.c                                     :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/11 23:15:09 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/11 23:15:09 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nint\thandle_redirection(t_command *cmd, t_token **current_token_ptr)\n{\n\tt_token\t*redir_token;\n\tt_redir\t*new_redir;\n\n\tredir_token = *current_token_ptr;\n\tif (redir_token->next->type != TOKEN_WORD)\n\t{\n\t\treturn (syntax_error_handler(redir_token->next->value));\n\t}\n\tnew_redir = create_redir_node(redir_token->type, redir_token->next->value);\n\tadd_redir_node_back(&cmd->redirections, new_redir);\n\t*current_token_ptr = (*current_token_ptr)->next->next;\n\treturn (1);\n}\n",
  "PARSER/nodes/cmd_nodes.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   cmd_nodes.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/11 23:15:23 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/11 23:15:23 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nt_command\t*create_command_node(void)\n{\n\tt_command\t*new_cmd;\n\n\tnew_cmd = (t_command *)gc_mall(sizeof(t_command));\n\tnew_cmd->args = NULL;\n\tnew_cmd->redirections = NULL;\n\tnew_cmd->next_piped_command = NULL;\n\treturn (new_cmd);\n}\n\nvoid\tadd_command_node_back(t_command **list, t_command *new_cmd)\n{\n\tt_command\t*current;\n\n\tif (!list || !new_cmd)\n\t\treturn ;\n\tif (*list == NULL)\n\t{\n\t\t*list = new_cmd;\n\t\treturn ;\n\t}\n\tcurrent = *list;\n\twhile (current->next_piped_command != NULL)\n\t\tcurrent = current->next_piped_command;\n\tcurrent->next_piped_command = new_cmd;\n}\n",
  "PARSER/nodes/redir_nodes.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   redir_nodes.c                                      :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/11 23:15:32 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/11 23:15:32 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nstatic bool\tis_quoted(const char *str)\n{\n\tsize_t\tlen;\n\n\tif (!str)\n\t\treturn (false);\n\tlen = ft_strlen(str);\n\tif (len < 2)\n\t\treturn (false);\n\tif (str[0] == '\\'' && str[len - 1] == '\\'')\n\t\treturn (true);\n\tif (str[0] == '\\\"' && str[len - 1] == '\\\"')\n\t\treturn (true);\n\treturn (false);\n}\n\nt_redir\t*create_redir_node(t_token_type type, char *filename)\n{\n\tt_redir\t*new_redir;\n\n\tnew_redir = (t_redir *)gc_mall(sizeof(t_redir));\n\tif (type == TOKEN_REDIR_IN)\n\t\tnew_redir->type = REDIR_INPUT;\n\telse if (type == TOKEN_REDIR_OUT)\n\t\tnew_redir->type = REDIR_OUTPUT_TRUNC;\n\telse if (type == TOKEN_REDIR_APPEND)\n\t\tnew_redir->type = REDIR_OUTPUT_APPEND;\n\telse if (type == TOKEN_REDIR_HEREDOC)\n\t\tnew_redir->type = REDIR_HEREDOC;\n\tnew_redir->del_or_fname = gc_strdup(filename);\n\tnew_redir->heredoc_fd = -1;\n\tnew_redir->expand_in_heredoc = !is_quoted(filename);\n\tnew_redir->next = NULL;\n\treturn (new_redir);\n}\n\nvoid\tadd_redir_node_back(t_redir **list, t_redir *new_redir)\n{\n\tt_redir\t*current;\n\n\tif (!list || !new_redir)\n\t\treturn ;\n\tif (*list == NULL)\n\t{\n\t\t*list = new_redir;\n\t\treturn ;\n\t}\n\tcurrent = *list;\n\twhile (current->next != NULL)\n\t\tcurrent = current->next;\n\tcurrent->next = new_redir;\n}\n",
  "TOKENIZER/nodes.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   nodes.c                                            :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/06 19:17:32 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/06 19:17:32 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nt_token\t*create_token(t_token_type type, char *value)\n{\n\tt_token\t*new_token;\n\n\tnew_token = (t_token *)gc_mall(sizeof(t_token));\n\tnew_token->type = type;\n\tif (value)\n\t\tnew_token->value = gc_strdup(value);\n\telse\n\t\tnew_token->value = NULL;\n\tnew_token->next = NULL;\n\treturn (new_token);\n}\n\nvoid\tadd_token_back(t_token **list, t_token *new_token)\n{\n\tt_token\t*current;\n\n\tif (!list || !new_token)\n\t\treturn ;\n\tif (*list == NULL)\n\t{\n\t\t*list = new_token;\n\t\treturn ;\n\t}\n\tcurrent = *list;\n\twhile (current->next != NULL)\n\t{\n\t\tcurrent = current->next;\n\t}\n\tcurrent->next = new_token;\n}\n",
  "TOKENIZER/operators.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   operators.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/06 19:11:58 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/06 19:11:58 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nt_token\t*get_operator_token(char *line, int *i)\n{\n\tif (line[*i] == '|')\n\t\treturn ((*i)++, create_token(TOKEN_PIPE, \"|\"));\n\tif (line[*i] == '>')\n\t{\n\t\t(*i)++;\n\t\tif (line[*i] == '>')\n\t\t\treturn ((*i)++, create_token(TOKEN_REDIR_APPEND, \">>\"));\n\t\treturn (create_token(TOKEN_REDIR_OUT, \">\"));\n\t}\n\tif (line[*i] == '<')\n\t{\n\t\t(*i)++;\n\t\tif (line[*i] == '<')\n\t\t\treturn ((*i)++, create_token(TOKEN_REDIR_HEREDOC, \"<<\"));\n\t\treturn (create_token(TOKEN_REDIR_IN, \"<\"));\n\t}\n\treturn (NULL);\n}\n",
  "TOKENIZER/tokenizer.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   tokenizer.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/06 19:15:46 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/06 19:16:10 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nt_token\t*tokenizer(char *line)\n{\n\tt_token\t*tokens;\n\tt_token\t*new_token;\n\tint\t\ti;\n\n\ttokens = NULL;\n\ti = 0;\n\twhile (line[i])\n\t{\n\t\tif (ft_isspace(line[i]))\n\t\t{\n\t\t\ti++;\n\t\t\tcontinue ;\n\t\t}\n\t\tif (is_metachar(line[i]))\n\t\t\tnew_token = get_operator_token(line, &i);\n\t\telse\n\t\t\tnew_token = get_word_token(line, &i);\n\t\tif (new_token == NULL)\n\t\t\treturn (NULL);\n\t\tif (new_token == (void *)1)\n\t\t\tcontinue ;\n\t\tadd_token_back(&tokens, new_token);\n\t}\n\tadd_token_back(&tokens, create_token(TOKEN_EOF, NULL));\n\treturn (tokens);\n}\n",
  "TOKENIZER/tools.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   tools.c                                            :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/06 19:19:15 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/06 19:19:15 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nint\tft_isspace(char c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\n' || \\\n\t\t\tc == '\\v' || c == '\\f' || c == '\\r');\n}\n\nint\tis_metachar(char c)\n{\n\treturn (c == '|' || c == '<' || c == '>');\n}\n\nint\tis_unsupported_metachar(char c)\n{\n\tif (c == ';' || c == '\\\\' || c == '&' || c == '(' || c == ')' || \\\n\t\tc == '{' || c == '}')\n\t\treturn (1);\n\treturn (0);\n}\n",
  "TOKENIZER/words.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   words.c                                            :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/06 19:13:51 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/06 19:13:56 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nstatic char\t*extract_quoted_part(char *line, int *i)\n{\n\tchar\tquote_char;\n\tint\t\tstart;\n\n\tquote_char = line[*i];\n\tstart = *i;\n\t(*i)++;\n\twhile (line[*i] && line[*i] != quote_char)\n\t\t(*i)++;\n\tif (line[*i] == '\\0')\n\t{\n\t\tft_putstr_fd(\"minishell: syntax error: unclosed quote\\n\", 2);\n\t\treturn (NULL);\n\t}\n\t(*i)++;\n\treturn (gc_substr(line, start, *i - start));\n}\n\nstatic char\t*extract_unquoted_part(char *line, int *i)\n{\n\tint\tstart;\n\n\tstart = *i;\n\twhile (line[*i] && !ft_isspace(line[*i]) && !is_metachar(line[*i])\n\t\t&& line[*i] != '\\'' && line[*i] != '\"')\n\t\t(*i)++;\n\treturn (gc_substr(line, start, *i - start));\n}\n\nt_token\t*get_word_token(char *line, int *i)\n{\n\tchar\t*word_so_far;\n\tchar\t*next_part;\n\tchar\t*temp;\n\n\tword_so_far = gc_strdup(\"\");\n\tif (!word_so_far)\n\t\treturn (NULL);\n\twhile (line[*i] && !ft_isspace(line[*i]) && !is_metachar(line[*i]))\n\t{\n\t\tif (line[*i] == '\\'' || line[*i] == '\"')\n\t\t\tnext_part = extract_quoted_part(line, i);\n\t\telse\n\t\t\tnext_part = extract_unquoted_part(line, i);\n\t\tif (!next_part)\n\t\t\treturn (NULL);\n\t\ttemp = word_so_far;\n\t\tword_so_far = gc_strjoin(temp, next_part);\n\t}\n\tif (ft_strlen(word_so_far) == 0)\n\t\treturn ((void *)1);\n\treturn (create_token(TOKEN_WORD, word_so_far));\n}\n",
  "tools/strings.c": "\n#include \"parsing.h\"\n\nint\tft_isalpha(int c)\n{\n\treturn ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'));\n}\n\nint\tft_isalnum(int c)\n{\n\treturn (ft_isalpha(c) || (c >= '0' && c <= '9'));\n}\n\nchar\t*ft_strjoin(char const *s1, char const *s2)\n{\n\tchar\t*new_str;\n\tsize_t\ti;\n\tsize_t\tj;\n\n\tif (!s1 || !s2)\n\t\treturn (NULL);\n\tnew_str = (char *)malloc(ft_strlen(s1) + ft_strlen(s2) + 1);\n\tif (!new_str)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (s1[i])\n\t{\n\t\tnew_str[i] = s1[i];\n\t\ti++;\n\t}\n\tj = 0;\n\twhile (s2[j])\n\t{\n\t\tnew_str[i + j] = s2[j];\n\t\tj++;\n\t}\n\tnew_str[i + j] = '\\0';\n\treturn (new_str);\n}\n\nint\tft_strcmp(const char *s1, const char *s2)\n{\n\tsize_t\ti;\n\n\ti = 0;\n\twhile (s1[i] && s2[i] && s1[i] == s2[i])\n\t\ti++;\n\treturn ((unsigned char)s1[i] - (unsigned char)s2[i]);\n}\n\nint\tft_strncmp(const char *s1, const char *s2, size_t n)\n{\n\tsize_t\ti;\n\n\ti = 0;\n\tif (n == 0)\n\t\treturn (0);\n\twhile (i < n - 1 && s1[i] && s2[i] && s1[i] == s2[i])\n\t\ti++;\n\treturn ((unsigned char)s1[i] - (unsigned char)s2[i]);\n}\n\nchar\t*ft_strdup(char *value)\n{\n\tchar\t*result;\n\tint\t\ti;\n\tint\t\tlen;\n\n\tif (!value)\n\t\treturn (NULL);\n\tlen = ft_strlen(value);\n\tresult = malloc(sizeof(char) * (len + 1));\n\tif (!result)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (value[i] != '\\0')\n\t{\n\t\tresult[i] = value[i];\n\t\ti++;\n\t}\n\tresult[i] = '\\0';\n\treturn (result);\n}\n\nsize_t\tft_strlen(const char *s)\n{\n\tsize_t\ti;\n\n\ti = 0;\n\tif (!s)\n\t\treturn (0);\n\twhile (s[i])\n\t\ti++;\n\treturn (i);\n}\n\nvoid\tft_putstr_fd(const char *s, int fd)\n{\n\tif (s)\n\t\twrite(fd, s, ft_strlen(s));\n}\n\nchar\t*ft_substr(char const *s, unsigned int start, size_t len)\n{\n\tsize_t\ti;\n\tchar\t*r;\n\tsize_t\ts_len;\n\n\tif (!s)\n\t\treturn (NULL);\n\ts_len = ft_strlen(s);\n\tif (s_len < start)\n\t\treturn (gc_strdup(\"\"));\n\tif (len > s_len - start)\n\t\tlen = s_len - start;\n\tr = malloc(len + 1);\n\tif (!r)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (i < len)\n\t{\n\t\tr[i] = s[start + i];\n\t\ti++;\n\t}\n\tr[i] = '\\0';\n\treturn (r);\n}\n// PASTE THIS CODE AT THE END OF YOUR tools/strings.c FILE\n\nstatic size_t\tcount_words(char const *s, char c)\n{\n\tsize_t\tcount;\n\tsize_t\ti;\n\n\tcount = 0;\n\ti = 0;\n\twhile (s && s[i])\n\t{\n\t\tif (s[i] != c)\n\t\t{\n\t\t\tcount++;\n\t\t\twhile (s[i] && s[i] != c)\n\t\t\t\ti++;\n\t\t}\n\t\telse\n\t\t\ti++;\n\t}\n\treturn (count);\n}\n\nchar\t**ft_split(char const *s, char c)\n{\n\tchar\t**arr;\n\tsize_t\ti;\n\tsize_t\tj;\n\tsize_t\tstart;\n\n\tif (!s)\n\t\treturn (NULL);\n\tarr = (char **)gc_mall(sizeof(char *) * (count_words(s, c) + 1));\n\tif (!arr)\n\t\treturn (NULL);\n\ti = 0;\n\tj = 0;\n\twhile (s[i])\n\t{\n\t\tif (s[i] != c)\n\t\t{\n\t\t\tstart = i;\n\t\t\twhile (s[i] && s[i] != c)\n\t\t\t\ti++;\n\t\t\tarr[j++] = gc_substr(s, start, i - start);\n\t\t}\n\t\telse\n\t\t\ti++;\n\t}\n\tarr[j] = NULL;\n\treturn (arr);\n}\nchar\t*ft_strchr(const char *s, int c)\n{\n\twhile (*s)\n\t{\n\t\tif (*s == (char)c)\n\t\t\treturn ((char *)s);\n\t\ts++;\n\t}\n\tif ((char)c == '\\0')\n\t\treturn ((char *)s);\n\treturn (NULL);\n}\n\nint\tft_atoi(const char *str)\n{\n\tint\t\ti;\n\tint\t\tsign;\n\tlong\tresult;\n\n\ti = 0;\n\tsign = 1;\n\tresult = 0;\n\twhile (str[i] == ' ' || (str[i] >= '\\t' && str[i] <= '\\r'))\n\t\ti++;\n\tif (str[i] == '-' || str[i] == '+')\n\t{\n\t\tif (str[i] == '-')\n\t\t\tsign = -1;\n\t\ti++;\n\t}\n\twhile (str[i] >= '0' && str[i] <= '9')\n\t{\n\t\tresult = result * 10 + (str[i] - '0');\n\t\ti++;\n\t}\n\treturn ((int)(result * sign));\n}\nstatic int\tcount_digits(int n)\n{\n\tint\tcount = 1;\n\n\twhile (n / 10)\n\t{\n\t\tn /= 10;\n\t\tcount++;\n\t}\n\treturn (count);\n}\n\nchar\t*ft_itoa(int n)\n{\n\tchar\t\t*str;\n\tlong\t\tnum;\n\tint\t\t\tlen;\n\tint\t\t\tis_negative;\n\n\tnum = n;\n\tis_negative = (num < 0);\n\tif (is_negative)\n\t\tnum = -num;\n\tlen = count_digits(num) + is_negative;\n\tstr = malloc(sizeof(char) * (len + 1));\n\tif (!str)\n\t\treturn (NULL);\n\tstr[len] = '\\0';\n\twhile (len-- > 0)\n\t{\n\t\tstr[len] = '0' + (num % 10);\n\t\tnum /= 10;\n\t\tif (len == 0 && is_negative)\n\t\t\tstr[0] = '-';\n\t}\n\treturn (str);\n}\n"
}