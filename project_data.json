{
  "main.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   main.c                                             :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/11 10:23:15 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/08/11 10:23:16 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n#include \"EXECUTION/execution.h\"\n#include <termios.h>\n#include <stdlib.h>\n\nvolatile sig_atomic_t\tg_signal_received = 0;\n\nstatic void\tsignal_handler(int sig)\n{\n\tg_signal_received = sig;\n\tif (sig == SIGINT)\n\t{\n\t\twrite(1, \"\\n\", 1);\n\t\trl_on_new_line();\n\t\trl_replace_line(\"\", 0);\n\t\trl_redisplay();\n\t}\n}\n\nstatic void\tsetup_signals(void)\n{\n\tstruct sigaction\tsa;\n\n\tg_signal_received = 0;\n\trl_catch_signals = 0;\n\tsa.sa_handler = signal_handler;\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = 0;\n\tsigaction(SIGINT, &sa, NULL);\n\tsignal(SIGQUIT, SIG_IGN);\n}\n\nstatic void\tinitialize_shell(t_shell *shell, char **envp)\n{\n\tchar\tcwd_buffer[1024];\n\n\tshell->envp = dupenv(envp);\n\tshell->last_exit_status = 0;\n\tif (getcwd(cwd_buffer, sizeof(cwd_buffer)) != NULL)\n\t{\n\t\tset_env(\"PWD\", cwd_buffer, shell);\n\t}\n\telse\n\t{\n\t\tperror(\"minishell: startup error\");\n\t\texit(1);\n\t}\n\tset_env(\"OLDPWD\", (const char *)NULL, shell);\n\tset_env(\"PATH\", \"/.brew/bin:/mnt/homes/oben-jha/.docker/bin\"\n\t\t\":/usr/gnu/bin:/usr/local/bin:/bin:/usr/bin:.\", shell);\n\tset_env(\"_\", \"/usr/bin/env\", shell);\n\tsetup_signals();\n}\n\nstatic void\trun_parsed_commands(t_command *commands, t_shell *shell)\n{\n\tstruct sigaction\tsa;\n\n\tif (process_heredoc_pipe(commands, shell))\n\t{\n\t\tif (main_expand(commands, shell))\n\t\t{\n\t\t\tquote_remover(commands);\n\t\t\texecutor(commands, shell);\n\t\t}\n\t\telse\n\t\t\tshell->last_exit_status = 1;\n\t}\n\tsa.sa_handler = signal_handler;\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = 0;\n\tsigaction(SIGINT, &sa, NULL);\n}\n\nstatic void\tprocess_input_line(char *line, t_shell *shell)\n{\n\tt_token\t\t*tokens;\n\tt_command\t*commands;\n\n\tif (*line)\n\t\tadd_history(line);\n\ttokens = tokenizer(line, &shell->last_exit_status);\n\tcommands = parser(tokens, &shell->last_exit_status);\n\tif (commands)\n\t\trun_parsed_commands(commands, shell);\n\tfree(line);\n\tgc_freed();\n}\n\nstatic void\tshell_loop(t_shell *shell, struct termios *term)\n{\n\tchar\t*line;\n\n\twhile (1)\n\t{\n\t\tline = readline(\"minishell> \");\n\t\tif (g_signal_received == SIGINT)\n\t\t{\n\t\t\tshell->last_exit_status = 1;\n\t\t\tg_signal_received = 0;\n\t\t}\n\t\tif (!line)\n\t\t{\n\t\t\tft_putstr_fd(\"exit\\n\", 1);\n\t\t\tbreak ;\n\t\t}\n\t\tprocess_input_line(line, shell);\n\t\ttcsetattr(STDIN_FILENO, TCSANOW, term);\n\t}\n}\n\nint\tmain(int argc, char **argv, char **envp)\n{\n\tt_shell\t\t\tshell;\n\tstruct termios\tterm;\n\n\t(void)argv;\n\tif (argc > 1)\n\t{\n\t\tprintf(\"usage : ./minishell\\n\");\n\t\treturn (1);\n\t}\n\tif (!envp || !isatty(1) || !isatty(0))\n\t\treturn (1);\n\tinitialize_shell(&shell, envp);\n\ttcgetattr(STDIN_FILENO, &term);\n\tshell_loop(&shell, &term);\n\tfree_env(shell.envp);\n\tgc_freed();\n\treturn (shell.last_exit_status);\n}",
  "Makefile": "NAME = minishell\n\nCC = cc\nCFLAGS = -Wall -Wextra -Werror #-g3 -fsanitize=address\nRM = rm -f\n\nREADLINE_PATH = /mnt/homes/oben-jha/homebrew/opt/readline\n\nINCLUDES = -I. \\\n           -IEXECUTION \\\n           -IEXECUTION/builtins \\\n           -IEXPAND \\\n           -IPARSER \\\n           -IPARSER/nodes \\\n           -ITOKENIZER \\\n           -IGARBAGE_COLLECTOR \\\n           -IHEREDOC \\\n           -Itools \\\n           -I$(READLINE_PATH)/include \n\n\nLDFLAGS = -L$(READLINE_PATH)/lib -lreadline\n\nSRCS = main.c \\\n       EXECUTION/builtins_dispatch.c \\\n       EXECUTION/env_utils.c \\\n       EXECUTION/executor.c \\\n       EXECUTION/path_finder.c \\\n       EXECUTION/redirections.c \\\n       EXECUTION/builtins/ft_cd.c \\\n       EXECUTION/builtins/ft_echo.c \\\n       EXECUTION/builtins/ft_env.c \\\n       EXECUTION/builtins/ft_exit.c \\\n       EXECUTION/builtins/ft_export.c \\\n       EXECUTION/builtins/ft_pwd.c \\\n       EXECUTION/builtins/ft_unset.c \\\n       EXECUTION/builtins/helpers.c \\\n       EXPAND/expand.c \\\n       EXPAND/g_expand.c \\\n       EXPAND/helper.c \\\n       EXPAND/quotes_removal.c \\\n       EXPAND/utils.c \\\n       EXPAND/utils_1.c \\\n       EXPAND/utils2.c \\\n       GARBAGE_COLLECTOR/gc_mall.c \\\n       GARBAGE_COLLECTOR/gc_mall2.c \\\n       HEREDOC/processor.c \\\n       HEREDOC/helpers.c \\\n       PARSER/error_handler.c \\\n       PARSER/processor.c \\\n       PARSER/redirections.c \\\n       PARSER/nodes/cmd_nodes.c \\\n       PARSER/nodes/redir_nodes.c \\\n       TOKENIZER/nodes.c \\\n       TOKENIZER/operators.c \\\n       TOKENIZER/tokenizer.c \\\n       TOKENIZER/tools.c \\\n       TOKENIZER/words.c \\\n       tools/strings.c \\\n       tools/strings1.c \\\n       tools/strings2.c \nOBJS = $(SRCS:.c=.o)\n\nall: $(NAME)\n\n$(NAME): $(OBJS)\n\t$(CC) $(OBJS) $(LDFLAGS)  $(CFLAGS) -o $(NAME)\n\n%.o: %.c\n\t$(CC) $(CFLAGS) $(INCLUDES) -c $< -o $@\n\nclean:\n\t$(RM) $(OBJS)\n\nfclean: clean\n\t$(RM) $(NAME)\n\nre: fclean all\n\n.PHONY: all clean fclean re",
  "parsing.h": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   parsing.h                                          :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/12 23:08:26 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/08/11 08:18:30 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#ifndef PARSING_H\n# define PARSING_H\n\n# include <stdlib.h>\n# include <stddef.h>\n# include <stdio.h>\n# include <stdbool.h>\n# include <unistd.h>\n# include <readline/readline.h>\n# include <readline/history.h>\n# include <signal.h>\n# include <sys/wait.h>\n\n# define SQUOTE_LOCK '\\x03'\n# define DQUOTE_LOCK '\\x04'\n\ntypedef struct s_shell\n{\n\tchar\t**envp;\n\tint\t\tlast_exit_status;\n}\tt_shell;\n\ntypedef struct s_gc_node\n{\n\tvoid\t\t\t\t*pt;\n\tstruct s_gc_node\t*next;\n}\tt_gc_node;\n\ntypedef enum e_token_type\n{\n\tTOKEN_WORD,\n\tTOKEN_PIPE,\n\tTOKEN_REDIR_IN,\n\tTOKEN_REDIR_OUT,\n\tTOKEN_REDIR_APPEND,\n\tTOKEN_REDIR_HEREDOC,\n\tTOKEN_NEWLINE,\n\tTOKEN_EOF,\n\tTOKEN_ERROR\n}\tt_token_type;\n\ntypedef struct s_token\n{\n\tt_token_type\ttype;\n\tchar\t\t\t*value;\n\tstruct s_token\t*next;\n}\tt_token;\n\ntypedef enum e_redir_type\n{\n\tREDIR_NONE,\n\tREDIR_INPUT,\n\tREDIR_OUTPUT_TRUNC,\n\tREDIR_OUTPUT_APPEND,\n\tREDIR_HEREDOC\n}\tt_redir_type;\n\ntypedef struct s_redir\n{\n\tt_redir_type\ttype;\n\tchar\t\t\t*del_or_fname;\n\tint\t\t\t\theredoc_fd;\n\tbool\t\t\texpand_in_heredoc;\n\tstruct s_redir\t*next;\n}\tt_redir;\n\ntypedef struct s_command\n{\n\tchar\t\t\t\t**args;\n\tt_redir\t\t\t\t*redirections;\n\tstruct s_command\t*next_piped_command;\n}\tt_command;\n\ntypedef struct s_arg_list\n{\n\tchar\t\t\t\t*arg;\n\tstruct s_arg_list\t*next;\n}\tt_arg_list;\n\ntypedef struct s_exp_data\n{\n\tt_shell\t\t\t\t*shell;\n\tint\t\t\t\t\t*flag;\n\tstruct\ts_exp_data\t*next;\n\tbool\t\t\t\texp_f;\n} t_exp_data;\n\nvoid\t\tgc_add_pt(void *pt);\nvoid\t\t*gc_mall(size_t size);\nchar\t\t*gc_strdup(char *str);\nvoid\t\tgc_freed(void);\nchar\t\t*gc_substr(char const *s, unsigned int start, size_t len);\nchar\t\t*gc_strjoin(char const *s1, char const *s2);\nchar\t\t*gc_itoa(int n);\n\n// TOKENIZER PROTOTYPES\nt_token\t\t*tokenizer(char *line, int *status);\nt_token\t\t*create_token(t_token_type type, char *value);\nvoid\t\tadd_token_back(t_token **list, t_token *new_token);\nt_token\t\t*get_operator_token(char *line, int *i);\nt_token\t\t*get_word_token(char *line, int *i, int *status);\n\n// PARSER PROTOTYPES\nt_command\t*parser(t_token *tokens, int *status);\nint\t\t\tsyntax_error_handler(char *token_value, int *status);\nt_command\t*create_command_node(void);\nvoid\t\tadd_command_node_back(t_command **list, t_command *new_cmd);\nt_redir\t\t*create_redir_node(t_token_type type, char *filename);\nvoid\t\tadd_redir_node_back(t_redir **list, t_redir *new_redir);\nint\t\t\thandle_redirection(t_command *cmd, t_token **current_token, int *s);\nvoid\t\t\theredoc_error();\n\n// HEREDOC PROTOTYPES\nint\t\t\tprocess_heredoc_pipe(t_command *cmds_head, t_shell *shell);\nchar    \t*final_delim(char *delim);\nvoid\t\theredoc_sigint_handler(int sig);\nchar\t\t*maybe_expand_line(char *line, bool flag, t_shell *shell);\n\n// EXPAND PROTOTYPES\nchar\t\t*expander(char *str, t_shell *shell, int *exp);\nvoid\t\tquote_remover(t_command *cmd_list);\nchar\t\t*strip_quotes(const char *str);\nint\t\t\tmain_expand(t_command *cmds, t_shell *shell);\nchar\t\t*my_getenv(const char *name, char **env);\nvoid\t\tadd_arg_to_list(t_arg_list **head, char *arg_val);\nchar\t\t**convert_list_to_array(t_arg_list *head);\nvoid\t\tinit_data(t_exp_data **data_ptr, t_shell *shell, int *exp);\nint\t\t\tflag_redir_error(char *exp, char *org, int count);\nchar\t\t*lock_quotes(const char *value);\nvoid\t\tunlock_quotes(char *arg);\nbool\t\tis_fully_quoted(const char *arg);\nbool\t\tis_valid_ass(const char *arg, int *is_quo);\nint\t\t\tit_has_tab(char *s);\nbool\t\thas_quotes(const char *str);\nvoid\t\tresplit_replace(char *splited, t_arg_list **head);\n\n\n\n// TOOLS/STRINGS PROTOTYPES\nchar\t\t*ft_strdup(char *value);\nint\t\t\tft_strncmp(const char *s1, const char *s2, size_t n);\nint\t\t\tft_strcmp(const char *s1, const char *s2);\nsize_t\t\tft_strlen(const char *s);\nvoid\t\tft_putstr_fd(const char *s, int fd);\nchar\t\t*ft_substr(char const *s, unsigned int start, size_t len);\nchar\t\t*ft_strjoin(char const *s1, char const *s2);\nint\t\t\tft_isalpha(int c);\nint\t\t\tft_isalnum(int c);\nchar\t\t*ft_itoa(int n);\nvoid\t\texecutor(t_command *commands, t_shell *shell);\nchar\t\t**dupenv(char **envp);\nvoid\t\tfree_env(char **envp);\nint\t\t\tft_atoi(const char *str);\nint\t\t\tis_void(char *s);\n\n\n\n// TOOLS/CHECKERS PROTOTYPES\nint\t\t\tft_isspace(char c);\nint\t\t\tis_metachar(char c);\nint\t\t\tdel_or_fnamesupported_metachar(char c);\nchar\t\t**ft_split(char const *s, char c);\nchar\t\t*ft_strchr(const char *s, int c);\n\n#endif\n\n",
  "EXECUTION/builtins_dispatch.c": "#include \"execution.h\"\n#include \"builtins/builtins.h\"\n\nint\tis_builtin(char *cmd)\n{\n\tif (!cmd)\n\t\treturn (0);\n\tif (ft_strcmp(cmd, \"echo\") == 0)\n\t\treturn (1);\n\tif (ft_strcmp(cmd, \"cd\") == 0)\n\t\treturn (1);\n\tif (ft_strcmp(cmd, \"pwd\") == 0)\n\t\treturn (1);\n\tif (ft_strcmp(cmd, \"export\") == 0)\n\t\treturn (1);\n\tif (ft_strcmp(cmd, \"unset\") == 0)\n\t\treturn (1);\n\tif (ft_strcmp(cmd, \"env\") == 0)\n\t\treturn (1);\n\tif (ft_strcmp(cmd, \"exit\") == 0)\n\t\treturn (1);\n\treturn (0);\n}\n\nint\tis_parent_builtin(char *cmd)\n{\n\tif (!cmd)\n\t\treturn (0);\n\tif (ft_strcmp(cmd, \"cd\") == 0)\n\t\treturn (1);\n\tif (ft_strcmp(cmd, \"export\") == 0)\n\t\treturn (1);\n\tif (ft_strcmp(cmd, \"unset\") == 0)\n\t\treturn (1);\n\tif (ft_strcmp(cmd, \"exit\") == 0)\n\t\treturn (1);\n\treturn (0);\n}\n\nvoid\texecute_builtin(t_command *cmd, t_shell *shell)\n{\n\tchar\t*cmd_name;\n\tint\t\tstatus;\n\n\tstatus = 0;\n\tif (!cmd || !cmd->args || !cmd->args[0])\n\t\treturn ;\n\tcmd_name = cmd->args[0];\n\tif (ft_strcmp(cmd_name, \"echo\") == 0)\n\t\tstatus = ft_echo(cmd->args);\n\telse if (ft_strcmp(cmd_name, \"cd\") == 0)\n\t\tstatus = ft_cd(cmd->args, shell);\n\telse if (ft_strcmp(cmd_name, \"pwd\") == 0)\n\t\tstatus = ft_pwd(shell);\n\telse if (ft_strcmp(cmd_name, \"export\") == 0)\n\t\tstatus = ft_export(cmd->args, shell);\n\telse if (ft_strcmp(cmd_name, \"unset\") == 0)\n\t\tstatus = ft_unset(cmd->args, shell);\n\telse if (ft_strcmp(cmd_name, \"env\") == 0)\n\t\tstatus = ft_env(shell);\n\telse if (ft_strcmp(cmd_name, \"exit\") == 0)\n\t\tstatus = ft_exit(cmd->args, shell);\n\tshell->last_exit_status = status;\n}",
  "EXECUTION/env_utils.c": "#include \"../parsing.h\"\n#include <stdlib.h>\n\nstatic int\tcount_env_vars(char **envp)\n{\n\tint\ti;\n\n\ti = 0;\n\tif (!envp)\n\t\treturn (0);\n\twhile (envp[i])\n\t\ti++;\n\treturn (i);\n}\n\nvoid\tfree_env(char **envp)\n{\n\tint\ti;\n\n\tif (!envp)\n\t\treturn ;\n\ti = 0;\n\twhile (envp[i])\n\t{\n\t\tfree(envp[i]);\n\t\ti++;\n\t}\n\tfree(envp);\n}\n\nchar\t**dupenv(char **envp)\n{\n\tint\t\ti;\n\tint\t\tcount;\n\tchar\t**new_envp;\n\tint \ta;\n\n\tcount = count_env_vars(envp);\n\tnew_envp = (char **)malloc(sizeof(char *) * (count + 1));\n\tif (!new_envp)\n\t\treturn (NULL);\n\ti = 0;\n\ta = 0;\n\twhile (i < count)\n\t{\n\t\tif (ft_strncmp(envp[i], \"OLDPWD\", 6) == 0)\n\t\t\ti++;\n\t\tnew_envp[a] = ft_strdup(envp[i]);\n\t\tif (!new_envp[a])\n\t\t{\n\t\t\twhile (--a >= 0)\n\t\t\t\tfree(new_envp[a]);\n\t\t\tfree(new_envp);\n\t\t\treturn (NULL);\n\t\t}\n\t\ti++;\n\t\ta++;\n\t}\n\tnew_envp[i] = NULL;\n\treturn (new_envp);\n}\n\nchar\t*my_getenv(const char *name, char **env)\n{\n\tint\t\ti;\n\tsize_t\tname_len;\n\n\tif (!name || !env)\n\t\treturn (NULL);\n\tname_len = ft_strlen(name);\n\ti = 0;\n\twhile (env[i])\n\t{\n\t\tif (ft_strncmp(env[i], name, name_len) == 0)\n\t\t{\n\t\t\tif (env[i][name_len] == '=')\n\t\t\t\treturn (env[i] + name_len + 1);\n\t\t}\n\t\ti++;\n\t}\n\treturn (NULL);\n}\n\nint\tset_env(const char *name, const char *value, t_shell *shell)\n{\n\tint\t\ti;\n\tsize_t\tname_len;\n\tchar\t*new_var;\n\tchar\t*temp;\n\tchar\t**new_envp;\n\n\tif (value != (char const *)NULL)\n\t{\n\t\tname_len = ft_strlen(name);\n\t\ttemp = ft_strjoin(name, \"=\");\n\t\tnew_var = ft_strjoin(temp, value);\t\n\t\tfree(temp);\n\t}\n\telse \n\t\tnew_var = ft_strdup((char *)name);\n\tif (!new_var)\n\t\treturn (1);\n\ti = 0;\n\twhile (shell->envp[i])\n\t{\n\t\tif (ft_strncmp(shell->envp[i], name, name_len) == 0)\n\t\t{\n\t\t\tfree(shell->envp[i]);\n\t\t\tshell->envp[i] = new_var;\n\t\t\treturn (0);\n\t\t}\n\t\ti++;\n\t}\n\tnew_envp = malloc(sizeof(char *) * (i + 2));\n\tif (!new_envp)\n\t{\n\t\tfree(new_var);\n\t\treturn (1);\n\t}\n\ti = -1;\n\twhile (shell->envp[++i])\n\t\tnew_envp[i] = shell->envp[i];\n\tnew_envp[i] = new_var;\n\tnew_envp[i + 1] = NULL;\n\tfree(shell->envp);\n\tshell->envp = new_envp;\n\treturn (0);\n}\n\nchar\t**get_filtered_envp(char **envp)\n{\n\tint\t\ti;\n\tint\t\tj;\n\tint\t\tcount;\n\tchar\t**filtered_envp;\n\n\tcount = 0;\n\ti = 0;\n\twhile (envp[i])\n\t{\n\t\tif (ft_strchr(envp[i], '='))\n\t\t\tcount++;\n\t\ti++;\n\t}\n\tfiltered_envp = malloc(sizeof(char *) * (count + 1));\n\tif (!filtered_envp)\n\t\treturn (NULL);\n\ti = 0;\n\tj = 0;\n\twhile (envp[i])\n\t{\n\t\tif (ft_strchr(envp[i], '='))\n\t\t\tfiltered_envp[j++] = envp[i];\n\t\ti++;\n\t}\n\tfiltered_envp[j] = NULL;\n\treturn (filtered_envp);\n}\n",
  "EXECUTION/execution.h": "#ifndef EXECUTION_H\n# define EXECUTION_H\n\n# include \"../parsing.h\"\n# include <fcntl.h>\n# include <sys/wait.h>\n# include <sys/stat.h>\n# include <string.h>\n# include <errno.h>\n\nint\t\tset_env(const char *name, const char *value, t_shell *shell);\nint\t\thandle_redirections(t_command *cmd);\nvoid\trestore_fds(int original_stdin, int original_stdout);\nint\t\twait_for_children(pid_t last_pid);\nchar\t*find_path(char *cmd, char **envp);\nint\t\tis_builtin(char *cmd);\nvoid\texecute_builtin(t_command *cmd, t_shell *shell);\nint\t\tis_parent_builtin(char *cmd);\nint\t    handle_input_redirections(t_command *cmd);\nint\t    handle_output_redirections(t_command *cmd);\nchar\t**get_filtered_envp(char **envp);\n\n#endif",
  "EXECUTION/executor.c": "#include \"execution.h\"\n\nstatic void\texec_command(t_command *cmd, t_shell *shell)\n{\n\tchar\t*path;\n\n\tif (!cmd->args || !cmd->args[0])\n\t\texit(0);\n\tif (is_builtin(cmd->args[0]))\n\t{\n\t\texecute_builtin(cmd, shell);\n\t\texit(shell->last_exit_status);\n\t}\n\tpath = find_path(cmd->args[0], shell->envp);\n\tif (!path)\n\t\texit(127);\n\texecve(path, cmd->args, shell->envp);\n\tft_putstr_fd(\"minishell: \", 2);\n\tft_putstr_fd(cmd->args[0], 2);\n\tft_putstr_fd(\": \", 2);\n\tft_putstr_fd(strerror(errno), 2);\n\tft_putstr_fd(\"\\n\", 2);\n\tif (errno == EACCES)\n\t\texit(126);\n\texit(1);\n}\n\nstatic void\trun_child(t_command *cmd, t_shell *shell)\n{\n\tchar\t*path;\n\tchar\t**filtered_envp;\n\n\t(signal(SIGINT, SIG_DFL), signal(SIGQUIT, SIG_DFL));\n\tif (handle_redirections(cmd) == -1)\n\t\texit(1);\n\tif (!cmd->args || !cmd->args[0])\n\t\texit(0);\n\tif (is_builtin(cmd->args[0]))\n\t\t(execute_builtin(cmd, shell), exit(shell->last_exit_status));\n\tpath = find_path(cmd->args[0], shell->envp);\n\tif (!path)\n\t\texit(127);\n\tfiltered_envp = get_filtered_envp(shell->envp);\n\t(execve(path, cmd->args, filtered_envp), free(filtered_envp));\n\tif (errno == EACCES)\n\t{\n\t\t(ft_putstr_fd(\"minishell: \", 2), ft_putstr_fd(cmd->args[0], 2));\n\t\t(ft_putstr_fd(\": \", 2), ft_putstr_fd(\"command not found\", 2));\n\t\t(ft_putstr_fd(\"\\n\", 2), exit(127));\n\t}\n\tif (errno != ENOEXEC)\n\t{\n\t\t// printf(\"hre\\n\");\n\t\tft_putstr_fd(\"minishell: \", 2);\n\t\tft_putstr_fd(cmd->args[0], 2);\n\t\tft_putstr_fd(\": \", 2);\n\t\tft_putstr_fd(strerror(errno), 2);\n\t\tft_putstr_fd(\"\\n\", 2);\n\t}\n\telse if (errno == ENOEXEC)\n        exit(0);\n\texit(1);\n}\nstatic void\tchild_process_pipeline(t_command *cmd, t_shell *shell,\n\t\tint in_fd, int *pipe_fd)\n{\n\tsignal(SIGINT, SIG_DFL);\n\tsignal(SIGQUIT, SIG_DFL);\n\n\tif (in_fd != STDIN_FILENO)\n\t{\n\t\tdup2(in_fd, STDIN_FILENO);\n\t\tclose(in_fd);\n\t}\n\n\tif (cmd->next_piped_command)\n\t{\n\t\tclose(pipe_fd[0]);\n\t\tdup2(pipe_fd[1], STDOUT_FILENO);\n\t\tclose(pipe_fd[1]);\n\t}\n\tif (handle_redirections(cmd) == -1)\n\t\texit(1);\n\texec_command(cmd, shell);\n}\nstatic void\tparent_handle_pipe_fds(int *in_fd, int *pipe_fd, t_command *cmd)\n{\n\tif (*in_fd != STDIN_FILENO)\n\t\tclose(*in_fd);\n\tif (cmd->next_piped_command)\n\t{\n\t\tclose(pipe_fd[1]);\n\t\t*in_fd = pipe_fd[0];\n\t}\n}\n\nstatic void execute_pipeline(t_command *cmd, t_shell *shell)\n{\n    int   pipe_fd[2];\n    int   in_fd;\n    pid_t pid;\n\n    in_fd = STDIN_FILENO;\n    pid = -1;\n    while (cmd)\n    {\n        if (cmd->next_piped_command)\n        {\n            if (pipe(pipe_fd) == -1)\n            {\n                perror(\"minishell: pipe\");\n                shell->last_exit_status = 1;\n                wait_for_children(pid);\n                return;\n            }\n        }\n        pid = fork();\n        if (pid == -1)\n        {\n            perror(\"minishell: fork\");\n            shell->last_exit_status = 1;\n            close(in_fd);\n            if (cmd->next_piped_command)\n                (close(pipe_fd[0]),  close(pipe_fd[1]));\n            wait_for_children(-1);\n            return;\n        }\n        if (pid == 0)\n            child_process_pipeline(cmd, shell, in_fd, pipe_fd);\n        parent_handle_pipe_fds(&in_fd, pipe_fd, cmd);\n        cmd = cmd->next_piped_command;\n    }\n    shell->last_exit_status = wait_for_children(pid);\n}\n\nvoid\texecutor(t_command *commands, t_shell *shell)\n{\n\tpid_t\tpid;\n\tint\t\toriginal_fds[2];\n\n\tif (!commands)\n\t\treturn ;\n\tsignal(SIGINT, SIG_IGN);\n\tsignal(SIGQUIT, SIG_IGN);\n\tif (commands->next_piped_command)\n\t\texecute_pipeline(commands, shell);\n\telse\n\t{\n\t\tif (commands->args && commands->args[0] && is_parent_builtin(commands->args[0]))\n\t\t{\n\t\t\toriginal_fds[0] = dup(STDIN_FILENO);\n\t\t\toriginal_fds[1] = dup(STDOUT_FILENO);\n\t\t\tif (handle_redirections(commands) == -1)\n\t\t\t{\n\t\t\t\tshell->last_exit_status = 1;\n\t\t\t\trestore_fds(original_fds[0], original_fds[1]);\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\texecute_builtin(commands, shell);\n\t\t\trestore_fds(original_fds[0], original_fds[1]);\n\t\t\treturn ;\n\t\t}\n\t\tpid = fork();\n\t\tif (pid == -1)\n\t\t{\n\t\t\tshell->last_exit_status = 1;\n\t\t\treturn;\n\t\t}\n\t\tif (pid == 0)\n\t\t\trun_child(commands, shell);\n\t\tshell->last_exit_status = wait_for_children(pid);\n\t}\n}\n",
  "EXECUTION/path_finder.c": "#include \"execution.h\"\nstatic int\tis_directory(const char *path)\n{\n\tint\t\tfd;\n\tchar\tbuffer;\n\n\tfd = open(path, O_RDONLY);\n\tif (fd == -1)\n\t\treturn (0);\n\tif (read(fd, &buffer, 0) == -1 && errno == EISDIR)\n\t{\n\t\tclose(fd);\n\t\treturn (1);\n\t}\n\tclose(fd);\n\treturn (0);\n}\n\nstatic char\t*get_path_from_env(char **envp)\n{\n\tint\ti;\n\n\ti = 0;\n\twhile (envp && envp[i])\n\t{\n\t\tif (ft_strncmp(envp[i], \"PATH=\", 5) == 0)\n\t\t\treturn (envp[i] + 5);\n\t\ti++;\n\t}\n\treturn (NULL);\n}\n\nstatic char\t*check_paths(char *cmd, char **paths)\n{\n\tint\t\ti;\n\tchar\t*path_part;\n\tchar\t*full_path;\n\n\ti = 0;\n\t\n\twhile (paths[i])\n\t{\n\t\tpath_part = gc_strjoin(paths[i], \"/\");\n\t\tfull_path = gc_strjoin(path_part, cmd);\n\t\tif (access(full_path, X_OK) == 0)\n\t\t\treturn (full_path);\t\n\t\ti++;\n\t}\n\treturn (NULL);\n}\n\nstatic char\t*check_absolute_path(char *cmd)\n{\n\n\tif (is_directory(cmd))\n\t{\n\t\tft_putstr_fd(\"minishell: \", 2);\n\t\tft_putstr_fd(cmd, 2);\n\t\tft_putstr_fd(\": is a directory\\n\", 2);\n\t\texit(126);\n\t}\n\tif (access(cmd, X_OK) < 0)\n\t{\n\t\tft_putstr_fd(\"minishell: \", 2);\n    \tperror(cmd);\n    \tif (errno == ENOTDIR || errno == EACCES)\n\t\t\texit(126);\n\t\telse \t\n\t\t\texit(127);\n\t}\n\treturn (gc_strdup(cmd));\n}\n\nchar *find_path(char *cmd, char **envp)\n{\n    char    **paths;\n    char    *path_env;\n    char    *executable_path;\n\n    if (!cmd || *cmd == '\\0') {\n        ft_putstr_fd(\"minishell: : command not found\\n\", 2);\n        exit(127);\n    }\n    if (ft_strchr(cmd, '/'))\n        return (check_absolute_path(cmd));\n    path_env = get_path_from_env(envp);\n    if (path_env)\n    {\n        paths = ft_split(path_env, ':');\n        executable_path = check_paths(cmd, paths);\n        if (executable_path)\n            return (executable_path);\n    }\n    if (access(cmd, X_OK) == 0)\n        return (gc_strdup(cmd));\n\tif (path_env)\n\t{\n\t\tft_putstr_fd(\"minishell: \", 2);\n    \tft_putstr_fd(cmd, 2);\n    \tft_putstr_fd(\": command not found\\n\", 2);\n\t\texit(127);\n\t}\n    ft_putstr_fd(\"minishell: \", 2);\n\tperror(cmd);\n\texit(127);\n\t\n}\n\n",
  "EXECUTION/redirections.c": "#include \"execution.h\"\n\nstatic int\thandle_input_redir(t_redir *redir)\n{\n\tint\tfd;\n\n\tif (redir->type == REDIR_INPUT)\n\t{\n\t\tfd = open(redir->del_or_fname, O_RDONLY);\n\t\tif (fd == -1)\n\t\t{\n\t\t\tft_putstr_fd(\"minishell: \", 2);\n\t\t\tperror(redir->del_or_fname);\n\t\t\treturn (-1);\n\t\t}\n\t\tdup2(fd, STDIN_FILENO);\n\t\tclose(fd);\n\t}\n\telse\n\t{\n\t\tdup2(redir->heredoc_fd, STDIN_FILENO);\n\t\tclose(redir->heredoc_fd);\n\t}\n\treturn (0);\n}\n\nstatic int\thandle_output_redir(t_redir *redir)\n{\n\tint\tfd;\n\n\tif (redir->type == REDIR_OUTPUT_TRUNC)\n\t\tfd = open(redir->del_or_fname,\n\t\t\t\tO_WRONLY | O_CREAT | O_TRUNC, 0644);\n\telse\n\t\tfd = open(redir->del_or_fname,\n\t\t\t\tO_WRONLY | O_CREAT | O_APPEND, 0644);\n\tif (fd == -1)\n\t{\n\t\tft_putstr_fd(\"minishell: \", 2);\n\t\tperror(redir->del_or_fname);\n\t\treturn (-1);\n\t}\n\tdup2(fd, STDOUT_FILENO);\n\tclose(fd);\n\treturn (0);\n}\n\nint\thandle_redirections(t_command *cmd)\n{\n\tt_redir\t*redir;\n\n\tredir = cmd->redirections;\n\twhile (redir)\n\t{\n\t\tif (redir->type == REDIR_INPUT || redir->type == REDIR_HEREDOC)\n\t\t{\n\t\t\tif (handle_input_redir(redir) == -1)\n\t\t\t\treturn (-1);\n\t\t}\n\t\telse if (redir->type == REDIR_OUTPUT_TRUNC || redir->type == REDIR_OUTPUT_APPEND)\n\t\t{\n\t\t\tif (handle_output_redir(redir) == -1)\n\t\t\t\treturn (-1);\n\t\t}\n\t\tredir = redir->next;\n\t}\n\treturn (0);\n}\n\nvoid\trestore_fds(int original_stdin, int original_stdout)\n{\n\tdup2(original_stdin, STDIN_FILENO);\n\tdup2(original_stdout, STDOUT_FILENO);\n\tclose(original_stdin);\n\tclose(original_stdout);\n}\n\nint wait_for_children(pid_t last_pid)\n{\n    int status;\n    int exit_status;\n    int term_sig;\n\n    if (last_pid > 0)\n    {\n        waitpid(last_pid, &status, 0);\n        if (WIFEXITED(status))\n            exit_status = WEXITSTATUS(status);\n        else if (WIFSIGNALED(status))\n        {\n            term_sig = WTERMSIG(status);\n            exit_status = 128 + term_sig;\n            if (term_sig == SIGQUIT)\n                ft_putstr_fd(\"Quit\\n\", 2);\n        }\n    }\n    else\n        exit_status = 1; \n    while (wait(NULL) != -1 || errno != ECHILD)\n    {\n      \n    }\n    return (exit_status);\n}\n",
  "EXECUTION/status.c": "#include \"status.h\"\n\nstatic int\tg_shell_exit_status = 0;\n\nvoid\tset_exit_status(int status)\n{\n\tg_shell_exit_status = status;\n}\n\nint\tget_exit_status(void)\n{\n\treturn (g_shell_exit_status);\n}\n",
  "EXECUTION/status.h": "#ifndef STATUS_H\n# define STATUS_H\n\n# include <stdbool.h>\n\nvoid\tset_exit_status(int status);\nint\t\tget_exit_status(void);\n\n#endif\n",
  "EXECUTION/builtins/builtins.h": "#ifndef BUILTINS_H\n# define BUILTINS_H\n\n# include \"../execution.h\"\n\nint\t\tft_cd(char **args, t_shell *shell);\nint\t\tft_echo(char **args);\nint\t\tft_env(t_shell *shell);\nint\t\tft_exit(char **args, t_shell *shell);\nint\t\tft_export(char **args, t_shell *shell);\nint\t\tft_pwd(t_shell *shell);\nint\t\tft_unset(char **args, t_shell *shell);\nint     add_or_app_var(char *arg, char *eq, t_shell *shell);\nint     add_without_value(char *arg, t_shell *shell, int arg_len);\nint     is_valid_identifier(const char *s);\n\n\n#endif",
  "EXECUTION/builtins/ft_cd.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_cd.c                                            :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/08 13:05:12 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/08/08 13:05:12 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"builtins.h\"\n#include <unistd.h>\n#include <stdio.h>\n\nstatic int\tupdate_pwd_in_env(t_shell *shell)\n{\n\tchar\tcwd_buffer[1024];\n\tchar\t*old_pwd_val;\n\n\told_pwd_val = my_getenv(\"PWD\", shell->envp);\n\tif (old_pwd_val)\n\t\tset_env(\"OLDPWD\", old_pwd_val, shell);\n\tif (getcwd(cwd_buffer, sizeof(cwd_buffer)) != NULL)\n\t{\n\t\treturn (set_env(\"PWD\", cwd_buffer, shell));\n\t}\n\tperror(\"minishell: cd: getcwd\");\n\treturn (1);\n}\n\nint\tft_cd(char **args, t_shell *shell)\n{\n\tchar\t*path;\n\tchar\t*old_pwd_path;\n\n\tif (args[1] && args[2])\n\t\treturn (ft_putstr_fd(\"minishell: cd: too many arguments\\n\", 2), 1);\n\tpath = args[1];\n\tif (!path)\n\t{\n\t\tpath = my_getenv(\"HOME\", shell->envp);\n\t\tif (!path)\n\t\t\treturn (ft_putstr_fd(\"minishell: cd: HOME not set\\n\", 2), 1);\n\t}\n\telse if (ft_strcmp(path, \"-\") == 0)\n\t{\n\t\told_pwd_path = my_getenv(\"OLDPWD\", shell->envp);\n\t\tif (!old_pwd_path)\n\t\t\treturn (ft_putstr_fd(\"minishell: cd: OLDPWD not set\\n\", 2), 1);\n\t\tpath = old_pwd_path;\n\t\t(ft_putstr_fd(path, 1), ft_putstr_fd(\"\\n\", 1));\n\t}\n\tif (chdir(path) != 0)\n\t\treturn (ft_putstr_fd(\"minishell: cd: \", 2), perror(path), 1);\n\tupdate_pwd_in_env(shell);\n\treturn (0);\n}\n",
  "EXECUTION/builtins/ft_echo.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_echo.c                                          :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/08 13:05:38 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/08/08 13:05:38 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"builtins.h\"\n#include <stdio.h>\n\nstatic int\tcheck_n_option(char *arg)\n{\n\tint\ti;\n\n\tif (!arg || arg[0] != '-')\n\t\treturn (0);\n\ti = 1;\n\twhile (arg[i] == 'n')\n\t\ti++;\n\tif (arg[i] == '\\0')\n\t\treturn (1);\n\treturn (0);\n}\n\nint\tft_echo(char **args)\n{\n\tint\ti;\n\tint\tnewline_flag;\n\n\ti = 1;\n\tnewline_flag = 1;\n\twhile (args[i] && check_n_option(args[i]))\n\t{\n\t\tnewline_flag = 0;\n\t\ti++;\n\t}\n\twhile (args[i])\n\t{\n\t\tprintf(\"%s\", args[i]);\n\t\tif (args[i + 1])\n\t\t\tprintf(\" \");\n\t\ti++;\n\t}\n\tif (newline_flag)\n\t\tprintf(\"\\n\");\n\treturn (0);\n}\n",
  "EXECUTION/builtins/ft_env.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_env.c                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/08 13:06:14 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/08/08 13:09:42 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"builtins.h\"\n\nint\tft_env(t_shell *shell)\n{\n\tint\ti;\n\n\ti = 0;\n\tif (!shell->envp)\n\t\treturn (0);\n\twhile (shell->envp[i])\n\t{\n\t\tif (ft_strchr(shell->envp[i], '='))\n\t\t{\n\t\t\tft_putstr_fd(shell->envp[i], 1);\n\t\t\tft_putstr_fd(\"\\n\", 1);\n\t\t}\n\t\ti++;\n\t}\n\treturn (0);\n}\n",
  "EXECUTION/builtins/ft_exit.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_exit.c                                          :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/08 13:17:40 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/08/08 13:24:44 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"builtins.h\"\n\nstatic\tint\tis_numeric_char(char c)\n{\n\treturn (c >= '0' && c <= '9');\n}\n\nstatic\tint\tis_valid_exit_arg(char *n)\n{\n\tint\ti;\n\n\ti = 0;\n\tif (!n)\n\t\treturn (0);\n\twhile (ft_isspace(n[i]))\n\t\ti++;\n\tif (n[i] == '+' || n[i] == '-')\n\t\ti++;\n\tif (n[i] == '\\0')\n\t\treturn (0);\n\twhile (n[i])\n\t{\n\t\tif (!is_numeric_char(n[i]) && !ft_isspace(n[i]))\n\t\t\treturn (0);\n\t\ti++;\n\t}\n\treturn (1);\n}\n\nint\tft_exit(char **args, t_shell *shell)\n{\n\tlong long\tstatus;\n\n\tif (args[1] && args[2])\n\t{\n\t\tft_putstr_fd(\"exit\\n\", 1);\n\t\tft_putstr_fd(\"minishell: exit: too many arguments\\n\", 2);\n\t\treturn (1);\n\t}\n\tif (args[1])\n\t{\n\t\tft_putstr_fd(\"exit\\n\", 1);\n\t\tif (!is_valid_exit_arg(args[1]))\n\t\t{\n\t\t\tft_putstr_fd(\"minishell: exit: \", 2);\n\t\t\tft_putstr_fd(args[1], 2);\n\t\t\tft_putstr_fd(\": numeric argument required\\n\", 2);\n\t\t\texit(255);\n\t\t}\n\t\tstatus = ft_atoi(args[1]);\n\t\texit(status % 256);\n\t}\n\texit(shell->last_exit_status);\n\treturn (0);\n}\n",
  "EXECUTION/builtins/ft_export.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   ft_export.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/08 13:31:13 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/08/08 13:31:13 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"builtins.h\"\n\nstatic void\tbubble_sort_env(char **env, int count)\n{\n\tint\t\ti;\n\tint\t\tj;\n\tchar\t*temp;\n\tint\t\tswapped;\n\n\ti = 0;\n\twhile (i < count - 1)\n\t{\n\t\tswapped = 0;\n\t\tj = 0;\n\t\twhile (j < count - i - 1)\n\t\t{\n\t\t\tif (ft_strcmp(env[j], env[j + 1]) > 0)\n\t\t\t{\n\t\t\t\ttemp = env[j];\n\t\t\t\tenv[j] = env[j + 1];\n\t\t\t\tenv[j + 1] = temp;\n\t\t\t\tswapped = 1;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\tif (swapped == 0)\n\t\t\tbreak ;\n\t\ti++;\n\t}\n}\n\nstatic char\t**duplicate_env_for_sorting(char **envp, int *count)\n{\n\tint\t\ti;\n\tchar\t**new_envp;\n\n\t*count = 0;\n\twhile (envp && envp[*count])\n\t\t(*count)++;\n\tnew_envp = malloc(sizeof(char *) * (*count + 1));\n\tif (!new_envp)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (i < *count)\n\t{\n\t\tnew_envp[i] = envp[i];\n\t\ti++;\n\t}\n\tnew_envp[i] = NULL;\n\treturn (new_envp);\n}\n\nstatic int\tprint_exported_vars(char **envp)\n{\n\tint\t\ti;\n\tchar\t*equal_sign;\n\tint\t\tname_len;\n\tchar\t**sorted_envp;\n\n\tsorted_envp = duplicate_env_for_sorting(envp, &i);\n\tif (!sorted_envp)\n\t\treturn (1);\n\tbubble_sort_env(sorted_envp, i);\n\ti = -1;\n\twhile (sorted_envp && sorted_envp[++i])\n\t{\n\t\tft_putstr_fd(\"declare -x \", 1);\n\t\tequal_sign = ft_strchr(sorted_envp[i], '=');\n\t\tif (equal_sign)\n\t\t{\n\t\t\tname_len = equal_sign - sorted_envp[i];\n\t\t\t(write(1, sorted_envp[i], name_len), ft_putstr_fd(\"=\\\"\", 1));\n\t\t\t(ft_putstr_fd(equal_sign + 1, 1),ft_putstr_fd(\"\\\"\", 1));\n\t\t}\n\t\telse\n\t\t\tft_putstr_fd(sorted_envp[i], 1);\n\t\tft_putstr_fd(\"\\n\", 1);\n\t}\n\treturn (free(sorted_envp), 0);\n}\n\nstatic int\thandle_export_arg(char *arg, t_shell *shell)\n{\n\tchar\t*equal_sign;\n\tsize_t\targ_len;\n\n\t\n\tequal_sign = ft_strchr(arg, '=');\n\tif (equal_sign)\n\t{\n\t\tif (!add_or_app_var(arg, equal_sign, shell))\n\t\t\treturn (1);\n\t}\n\telse\n\t{\n\t\targ_len = ft_strlen(arg);\n\t\tif (!add_without_value(arg, shell, arg_len))\n\t\t\treturn (1);\n\t}\n\t\t\n\treturn (0);\n}\n\nint\tft_export(char **args, t_shell *shell)\n{\n\tint\ti;\n\tint\tstatus;\n\n\ti = 1;\n\tstatus = 0;\n\tif (!args[1])\n\t\treturn (print_exported_vars(shell->envp));\n\twhile (args[i])\n\t{\n\t\tif (!is_valid_identifier(args[i]))\n\t\t{\n\t\t\tft_putstr_fd(\"minishell: export: `\", 2);\n\t\t\tft_putstr_fd(args[i], 2);\n\t\t\tft_putstr_fd(\"': not a valid identifier\\n\", 2);\n\t\t\tstatus = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (handle_export_arg(args[i], shell) != 0)\n\t\t\t{\n\t\t\t\tft_putstr_fd(\"minishell: export: allocation error\\n\", 2);\n\t\t\t\tstatus = 1;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\treturn (status);\n}\n",
  "EXECUTION/builtins/ft_pwd.c": "#include \"builtins.h\"\n\nint\tft_pwd(t_shell *shell)\n{\n\tchar\t*pwd_val;\n\n\tpwd_val = my_getenv(\"PWD\", shell->envp);\t\t//hadi kadepandi 3la l 'env , lenv i9dro unset \n\tif (pwd_val)\n\t{\n\t\tft_putstr_fd(pwd_val, 1);\n\t\tft_putstr_fd(\"\\n\", 1);\n\t\treturn (0);\n\t}\n\tft_putstr_fd(\"minishell: pwd: PWD not set\\n\", 2);\n\treturn (1);\n}",
  "EXECUTION/builtins/ft_unset.c": "#include \"builtins.h\"\n\nstatic int\tcount_vars(char **envp)\n{\n\tint\ti;\n\n\ti = 0;\n\twhile (envp && envp[i])\n\t\ti++;\n\treturn (i);\n}\n\nstatic int\tremove_env_var(char *var_to_unset, char ***envp_ptr)\n{\n\tint\t\ti;\n\tint\t\tj;\n\tint\t\tcount;\n\tchar\t**new_envp;\n\tsize_t\tlen;\n\n\tlen = ft_strlen(var_to_unset);\n\tcount = count_vars(*envp_ptr);\n\tnew_envp = malloc(sizeof(char *) * (count + 1));\n\tif (!new_envp)\n\t\treturn (1);\n\ti = 0;\n\tj = 0;\n\twhile (i < count)\n\t{\n\t\tif (ft_strncmp((*envp_ptr)[i], var_to_unset, len) == 0\n\t\t\t&& ((*envp_ptr)[i][len] == '=' || (*envp_ptr)[i][len] == '\\0'))\n\t\t\tfree((*envp_ptr)[i]);\n\t\telse\n\t\t\tnew_envp[j++] = (*envp_ptr)[i];\n\t\ti++;\n\t}\n\tnew_envp[j] = NULL;\n\tfree(*envp_ptr);\n\t*envp_ptr = new_envp;\n\treturn (0);\n}\n\nint\tft_unset(char **args, t_shell *shell)\n{\n\tint\ti;\n\tint status;\n\n\ti = 1;\n\tstatus = 0;\n\twhile (args[i])\n\t{\n\t\tif (is_valid_identifier(args[i]))\n\t\t\tremove_env_var(args[i], &shell->envp);\n\t\telse\n\t\t{\n\t\t\tft_putstr_fd(\"minishell: export: `\", 2);\n\t\t\tft_putstr_fd(args[i], 2);\n\t\t\tft_putstr_fd(\"': not a valid identifier\\n\", 2);\n\t\t\tstatus = 1;\n\t\t}\n\t\ti++;\n\t}\n\treturn (status);\n}",
  "EXECUTION/builtins/helpers.c": "#include \"builtins.h\"\n\nint\tis_valid_identifier(const char *s)\n{\n\tint\ti;\n\n\tif (!s || (!ft_isalpha(s[0]) && s[0] != '_'))\n\t\treturn (0);\n\ti = 1;\n\twhile (s[i] && s[i] != '=' && s[i] != '+')\n\t{\n\t\tif (!ft_isalnum(s[i]) && s[i] != '_')\n\t\t\treturn (0);\n\t\ti++;\n\t}\n\treturn (1);\n}\n\nstatic int add_var(char *arg, char *eq, t_shell *shell)\n{\n    char *name;\n    char *value;\n\n    name = ft_substr(arg, 0, eq - arg);\n\tif (!name)\n\t\treturn (0);\n\tvalue = eq + 1;\n\tset_env(name, value, shell);\n\treturn (free(name), 1);\n}\n\nint add_or_app_var(char *arg, char *eq, t_shell *shell)\n{\n    char *name;\n    char *value;\n    char *existing_value;\n    char *new_val;\n\n    if (eq && eq > arg && *(eq - 1) == '+')\n    {\n        name = ft_substr(arg, 0, eq - arg - 1);\n        if (!name)\n            return (0);\n        value = eq + 1;\n        existing_value = my_getenv(name, shell->envp);\n        if (existing_value)\n        {\n            new_val = ft_strjoin(existing_value, value);\n            if (!new_val)\n                return (free(name), 0);\n            (set_env(name, new_val, shell), free(new_val));\n        }\n        else\n            set_env(name, value, shell);\n        return (free(name), 1);\n    }\n    else\n        return (add_var(arg, eq, shell));\n}\n\nint\tadd_without_value(char *arg, t_shell *shell, int arg_len)\n{\n\tint\t\ti;\n\tchar\t**new_envp;\n\n\ti = 0;\n\twhile (shell->envp[i])\n\t{\n\t\tif (ft_strncmp(shell->envp[i], arg, arg_len) == 0\n\t\t\t&& (shell->envp[i][arg_len] == '='\n\t\t\t\t|| shell->envp[i][arg_len] == '\\0'))\n\t\t\treturn (1);\n\t\ti++;\n\t}\n\tnew_envp = malloc(sizeof(char *) * (i + 2));\n\tif (!new_envp)\n\t\treturn (0);\n\ti = -1;\n\twhile (shell->envp[++i])\n\t\tnew_envp[i] = shell->envp[i];\n\tnew_envp[i] = ft_strdup(arg);\n\tif (!new_envp[i])\n\t\treturn (free(new_envp), 0);\n\tnew_envp[i + 1] = NULL;\n\tfree(shell->envp);\n\tshell->envp = new_envp;\n\treturn (1);\n}",
  "EXPAND/expand.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   expand.c                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/11 23:34:49 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/08/11 07:48:13 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n#include <stdlib.h>\n\nstatic void\tappend_char(char **s, char c)\n{\n\tchar\tto_append[2];\n\n\tto_append[0] = c;\n\tto_append[1] = '\\0';\n\t*s = gc_strjoin(*s, to_append);\n}\n\nstatic char\t*extract_variable_name(const char *str)\n{\n\tint\ti;\n\n\ti = 0;\n\tif (ft_isalpha(str[i]) || str[i] == '_')\n\t{\n\t\ti++;\n\t\twhile (ft_isalnum(str[i]) || str[i] == '_')\n\t\t\ti++;\n\t}\n\treturn (gc_substr(str, 0, i));\n}\n\nstatic void\thandle_dollar_expansion(char **new_str, const char *str,\n\t\tt_exp_data *data, int *i)\n{\n\tchar\t*key;\n\tchar\t*value;\n\tchar\t*locked_value;\n\n\t(*i)++;\n\tif (str[*i] == '?')\n\t{\n\t\t*new_str = gc_strjoin(*new_str, gc_itoa(data->shell->last_exit_status));\n\t\t(*i)++;\n\t\treturn ;\n\t}\n\tif (str[*i] == '\\'' || str[*i] == '\\\"' || str[*i] == '\\0')\n\t\treturn (append_char(new_str, '$'));\n\tkey = extract_variable_name(&str[*i]);\n\tif (!key || *key == '\\0')\n\t\treturn (append_char(new_str, '$'));\n\tvalue = my_getenv(key, data->shell->envp);\n\tif (value)\n\t{\n\t\tlocked_value = lock_quotes(value);\n\t\t*new_str = gc_strjoin(*new_str, locked_value);\n\t}\n\t*i += ft_strlen(key);\n\tif (value)\n\t\t*(data->flag) = 1;\n}\n\nchar\t*expander(char *str, t_shell *shell, int *exp)\n{\n\tchar\t\t*new_str;\n\tint\t\t\ti;\n\tbool\t\tin_dquote;\n\tbool\t\tin_squote;\n\tt_exp_data\t*data;\n\n\tif (!str)\n\t\treturn (NULL);\n\tnew_str = gc_strdup(\"\");\n\ti = 0;\n\tin_dquote = false;\n\tin_squote = false;\n\tinit_data(&data, shell, exp);\n\twhile (str[i])\n\t{\n\t\tif (str[i] == '\\'' && !in_dquote)\n\t\t\tin_squote = !in_squote;\n\t\telse if (str[i] == '\\\"' && !in_squote)\n\t\t\tin_dquote = !in_dquote;\n\t\tif (str[i] == '$' && !in_squote)\n\t\t\thandle_dollar_expansion(&new_str, str, data, &i);\n\t\telse\n\t\t\t(append_char(&new_str, str[i]), i++);\n\t}\n\treturn (new_str);\n}\n",
  "EXPAND/g_expand.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   g_expand.c                                         :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/13 05:41:03 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/14 15:12:23 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n#include <stdbool.h>\n\nstatic void\tex_sp(char *arg, t_shell *shell, t_arg_list **head, bool spl)\n{\n\tint\t\thas_expanded;\n\tchar\t*exp_str;\n\tchar\t**sp_words;\n\tint\t\tj;\n\n\thas_expanded = 0;\n\texp_str = expander(arg, shell, &has_expanded);\n\tif (exp_str[0] == '\\0')\n\t\treturn ;\n\tif ((has_expanded && !is_fully_quoted(arg) && !spl))\n\t{\n\t\tsp_words = ft_split(exp_str, ' ');\n\t\tj = 0;\n\t\twhile (sp_words && sp_words[j] && !is_void(sp_words[j]))\n\t\t{\n\t\t\tresplit_replace(sp_words[j], head);\n\t\t\tj++;\n\t\t}\n\t}\n\telse\n\t\tadd_arg_to_list(head, exp_str);\n}\n\nstatic void\trebuild_args_with_splitting(t_command *cmd, t_shell *shell)\n{\n\tt_arg_list\t*arg_head;\n\tint\t\t\ti;\n\tbool\t\tis_export;\n\tbool\t\tprevent_splitting_for_this_arg;\n\tint\t\t\tis_quoted_key;\n\n\tif (!cmd->args || !cmd->args[0])\n\t\treturn ;\n\targ_head = NULL;\n\tis_export = (ft_strcmp(cmd->args[0], \"export\") == 0);\n\ti = 0;\n\tis_quoted_key = 0;\n\twhile (cmd->args[i])\n\t{\n\t\tprevent_splitting_for_this_arg = false;\n\t\tif ((i > 0 && is_valid_ass(cmd->args[i], &is_quoted_key) && is_export)\n\t\t\t|| is_quoted_key)\n\t\t\tprevent_splitting_for_this_arg = true;\n\t\tex_sp(cmd->args[i], shell, &arg_head, prevent_splitting_for_this_arg);\n\t\ti++;\n\t}\n\tcmd->args = convert_list_to_array(arg_head);\n}\n\nstatic int\tprocess_single_redir(t_redir *redir, t_shell *shell, int *ex)\n{\n\tchar\t*original_str;\n\tchar\t*exp_str;\n\tchar\t**split_words;\n\tint\t\tword_count;\n\n\toriginal_str = redir->del_or_fname;\n\texp_str = expander(original_str, shell, ex);\n\tif (((*ex) && !is_fully_quoted(original_str)) || (ft_strlen(exp_str) == 0))\n\t{\n\t\tsplit_words = ft_split(exp_str, ' ');\n\t\tword_count = 0;\n\t\twhile (split_words && split_words[word_count])\n\t\t\tword_count++;\n\t\tif (word_count != 1)\n\t\t{\n\t\t\tflag_redir_error(exp_str, original_str, word_count);\n\t\t\tshell->last_exit_status = 1;\n\t\t\treturn (0);\n\t\t}\n\t\tredir->del_or_fname = split_words[0];\n\t}\n\telse\n\t\tredir->del_or_fname = exp_str;\n\treturn (1);\n}\n\nstatic int\texpand_and_check_redirs(t_command *cmd, t_shell *shell)\n{\n\tt_redir\t*redir;\n\tint\t\tex;\n\n\tredir = cmd->redirections;\n\tex = 0;\n\twhile (redir)\n\t{\n\t\tif (redir->type != REDIR_HEREDOC)\n\t\t{\n\t\t\tif (!process_single_redir(redir, shell, &ex))\n\t\t\t\treturn (0);\n\t\t}\n\t\tredir = redir->next;\n\t}\n\treturn (1);\n}\n\nint\tmain_expand(t_command *cmds, t_shell *shell)\n{\n\tt_command\t*cmd;\n\n\tif (!cmds)\n\t\treturn (1);\n\tcmd = cmds;\n\twhile (cmd)\n\t{\n\t\tif (!expand_and_check_redirs(cmd, shell))\n\t\t\treturn (0);\n\t\trebuild_args_with_splitting(cmd, shell);\n\t\tcmd = cmd->next_piped_command;\n\t}\n\treturn (1);\n}\n",
  "EXPAND/helper.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   helper.c                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/14 10:57:02 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/08/11 08:47:47 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nint\tflag_redir_error(char *exp, char *org, int count)\n{\n\tif (ft_strchr(exp, '$') && (count == 1))\n\t\treturn (ft_putstr_fd(\"minishell: : No such file or directory\\n\", 2), 0);\n\tif (count != 1)\n\t{\n\t\t(ft_putstr_fd(\"minishell: \", 2), ft_putstr_fd(org, 2));\n\t\treturn (ft_putstr_fd(\": ambiguous redirect\\n\", 2), 0);\n\t}\n\treturn (1);\n}\n\nvoid\tadd_arg_to_list(t_arg_list **head, char *arg_val)\n{\n\tt_arg_list\t*new_node;\n\tt_arg_list\t*current;\n\n\tnew_node = gc_mall(sizeof(t_arg_list));\n\tnew_node->arg = arg_val;\n\tnew_node->next = NULL;\n\tif (!*head)\n\t{\n\t\t*head = new_node;\n\t\treturn ;\n\t}\n\tcurrent = *head;\n\twhile (current->next)\n\t\tcurrent = current->next;\n\tcurrent->next = new_node;\n}\n\nchar\t**convert_list_to_array(t_arg_list *head)\n{\n\tint\t\t\tcount;\n\tt_arg_list\t*current;\n\tchar\t\t**array;\n\tint\t\t\ti;\n\n\tcount = 0;\n\tcurrent = head;\n\twhile (current)\n\t{\n\t\tcount++;\n\t\tcurrent = current->next;\n\t}\n\tarray = gc_mall(sizeof(char *) * (count + 1));\n\tcurrent = head;\n\ti = 0;\n\twhile (current)\n\t{\n\t\tarray[i++] = current->arg;\n\t\tcurrent = current->next;\n\t}\n\tarray[i] = NULL;\n\treturn (array);\n}\n\nvoid\tinit_data(t_exp_data **data_ptr, t_shell *shell, int *exp)\n{\n\t*data_ptr = gc_mall(sizeof(t_exp_data));\n\tif (!(*data_ptr))\n\t\treturn ;\n\t(*data_ptr)->shell = shell;\n\t(*data_ptr)->flag = exp;\n\t(*data_ptr)->next = NULL;\n}\n",
  "EXPAND/quotes_removal.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   quotes_removal.c                                   :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/11 23:37:45 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/11 23:37:45 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nstatic void\tclean_quotes_in_args(t_command *cmd)\n{\n\tint\t\ti;\n\tchar\t*stripped;\n\n\ti = 0;\n\tif (!cmd || !cmd->args)\n\t\treturn ;\n\twhile (cmd->args[i])\n\t{\n\t\tstripped = strip_quotes(cmd->args[i]);\n\t\tif (stripped)\n\t\t{\n\t\t\tunlock_quotes(stripped);\n\t\t\tcmd->args[i] = stripped;\n\t\t}\n\t\ti++;\n\t}\n}\n\nstatic void\tclean_quotes_in_redirs(t_command *cmd)\n{\n\tt_redir\t*redir;\n\tchar\t*stripped;\n\n\tif (!cmd)\n\t\treturn ;\n\tredir = cmd->redirections;\n\twhile (redir)\n\t{\n\t\tif (redir->type != REDIR_HEREDOC)\n\t\t{\n\t\t\tstripped = strip_quotes(redir->del_or_fname);\n\t\t\tif (stripped)\n\t\t\t\tredir->del_or_fname = stripped;\n\t\t}\n\t\tredir = redir->next;\n\t}\n}\n\nvoid\tquote_remover(t_command *cmd_list)\n{\n\twhile (cmd_list)\n\t{\n\t\tclean_quotes_in_args(cmd_list);\n\t\tclean_quotes_in_redirs(cmd_list);\n\t\tcmd_list = cmd_list->next_piped_command;\n\t}\n}\n",
  "EXPAND/utils.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   utils.c                                            :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/13 23:15:34 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/13 23:15:34 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\" \n\nstatic size_t\tcount_stripped_len(const char *str)\n{\n\tsize_t\ti;\n\tsize_t\tlen;\n\tbool\tin_squote;\n\tbool\tin_dquote;\n\n\ti = 0;\n\tlen = 0;\n\tin_squote = false;\n\tin_dquote = false;\n\twhile (str[i])\n\t{\n\t\tif (str[i] == '\\'' && !in_dquote)\n\t\t\tin_squote = !in_squote;\n\t\telse if (str[i] == '\\\"' && !in_squote)\n\t\t\tin_dquote = !in_dquote;\n\t\telse\n\t\t\tlen++;\n\t\ti++;\n\t}\n\treturn (len);\n}\n\nstatic void\tstrip_loop(const char *str, char *cleaned)\n{\n\tsize_t\ti;\n\tsize_t\tj;\n\tbool\tin_squote;\n\tbool\tin_dquote;\n\n\ti = 0;\n\tj = 0;\n\tin_squote = false;\n\tin_dquote = false;\n\twhile (str[i])\n\t{\n\t\tif (str[i] == '\\'' && !in_dquote)\n\t\t\tin_squote = !in_squote;\n\t\telse if (str[i] == '\\\"' && !in_squote)\n\t\t\tin_dquote = !in_dquote;\n\t\telse\n\t\t\tcleaned[j++] = str[i];\n\t\ti++;\n\t}\n\tcleaned[j] = '\\0';\n}\n\nchar\t*strip_quotes(const char *str)\n{\n\tchar\t*cleaned;\n\n\tif (!str)\n\t\treturn (NULL);\n\tcleaned = gc_mall(count_stripped_len(str) + 1);\n\tif (!cleaned)\n\t\treturn (NULL);\n\tstrip_loop(str, cleaned);\n\treturn (cleaned);\n}\n\nchar\t*lock_quotes(const char *value)\n{\n\tchar\t*locked_str;\n\tint\t\ti;\n\tbool\tin_squote;\n\tbool\tin_dquote;\n\n\tif (!value)\n\t\treturn (NULL);\n\tlocked_str = gc_mall(ft_strlen(value) + 1);\n\tif (!locked_str)\n\t\treturn (NULL);\n\ti = 0;\n\tin_squote = false;\n\tin_dquote = false;\n\twhile (value[i])\n\t{\n\t\tif (value[i] == '\\'' && !in_dquote)\n\t\t\t(locked_str[i] = SQUOTE_LOCK, in_squote = !in_squote);\n\t\telse if (value[i] == '\\\"' && !in_squote)\n\t\t\t(locked_str[i] = DQUOTE_LOCK, in_squote = !in_squote);\n\t\telse\n\t\t\tlocked_str[i] = value[i];\n\t\ti++;\n\t}\n\tlocked_str[i] = '\\0';\n\treturn (locked_str);\n}\n\nvoid\tunlock_quotes(char *arg)\n{\n\tint\ti;\n\n\tif (!arg)\n\t\treturn ;\n\ti = 0;\n\twhile (arg[i])\n\t{\n\t\tif (arg[i] == SQUOTE_LOCK)\n\t\t\targ[i] = '\\'';\n\t\telse if (arg[i] == DQUOTE_LOCK)\n\t\t\targ[i] = '\\\"';\n\t\ti++;\n\t}\n}\n",
  "EXPAND/utils2.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   utils2.c                                           :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/11 08:30:32 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/08/11 11:01:29 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nstatic void\tsplit_with_tab(char *sp, t_arg_list **head)\n{\n\tint\t\ti;\n\tchar\t**extra_split;\n\n\ti = 0;\n\textra_split = ft_split(sp, '\\t');\n\twhile (extra_split && extra_split[i] && (extra_split[i][0] != '$'\n\t\t&& extra_split[i][1] != '\\\"' && extra_split[i][1] != '\\'')\n\t\t&& (extra_split[i][1] != '\\'' && (extra_split[i][1] != '\\\"')))\n\t{\n\t\tadd_arg_to_list(head, extra_split[i]);\n\t\ti++;\n\t}\n}\n\nvoid\tresplit_replace(char *s, t_arg_list **head)\n{\n\tint\ti;\n\n\ti = 0;\n\tif (s[0] != '\\0' && ft_strcmp(s, \"$\\\"\\\"\") != 0\n\t\t&& ft_strcmp(s, \"$\\'\\'\") != 0\n\t\t&& ft_strcmp(s, \"\\\"\\\"\") != 0\n\t\t&& ft_strcmp(s, \"\\'\\'\") != 0)\n\t{\n\t\twhile (s[i] != '\\0')\n\t\t{\n\t\t\tif (s[i] == '$' && (s[i + 1] == '\\'' || s[i + 1] == '\\\"'))\n\t\t\t\ts[i] = '\\\"';\n\t\t\ti++;\n\t\t}\n\t\tif (it_has_tab(s))\n\t\t\tsplit_with_tab(s, head);\n\t\telse\n\t\t\tadd_arg_to_list(head, s);\n\t}\n}\n",
  "EXPAND/utils_1.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   utils_1.c                                          :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/03 10:59:44 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/08/11 10:10:45 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nint\tis_void(char *s)\n{\n\tif (!s)\n\t\treturn (1);\n\twhile (*s)\n\t{\n\t\tif (!ft_isspace(*s))\n\t\t\treturn (0);\n\t\ts++;\n\t}\n\treturn (1);\n}\n\nbool\tis_fully_quoted(const char *arg)\n{\n\tsize_t\tlen;\n\n\tif (!arg)\n\t\treturn (false);\n\tlen = ft_strlen(arg);\n\tif (len < 2)\n\t\treturn (false);\n\tif (arg[0] == '\\\"' && arg[len - 1] == '\\\"')\n\t\treturn (true);\n\tif (arg[0] == '\\'' && arg[len - 1] == '\\'')\n\t\treturn (true);\n\treturn (false);\n}\n\nbool\thas_quotes(const char *str)\n{\n\tif (!str)\n\t\treturn (false);\n\twhile (*str)\n\t{\n\t\tif (*str == '\\'' || *str == '\\\"')\n\t\t\treturn (true);\n\t\tstr++;\n\t}\n\treturn (false);\n}\n\nbool\tis_valid_ass(const char *arg, int *is_q)\n{\n\tchar\t*equal_sign;\n\tint\t\ti;\n\tint\t\tq;\n\n\tif (!arg)\n\t\treturn (false);\n\tq = 0;\n\tequal_sign = ft_strchr(arg, '=');\n\tif (equal_sign == NULL || equal_sign == arg)\n\t\treturn (false);\n\tif (equal_sign[1] == '\\\"' || equal_sign[1] == '\\'')\n\t{\n\t\tq = 1;\n\t\t(*is_q) = 1;\n\t}\n\tif (!ft_isalpha(arg[0]) && arg[0] != '_')\n\t\treturn (false);\n\ti = 1;\n\twhile (&arg[i] < equal_sign)\n\t{\n\t\tif (!ft_isalnum(arg[i]) && arg[i] != '_' && arg[i] != '+' && q == 0)\n\t\t\treturn (false);\n\t\ti++;\n\t}\n\treturn (true);\n}\n\nint\tit_has_tab(char *s)\n{\n\tint\ti;\n\n\ti = 0;\n\twhile (s[i])\n\t{\n\t\tif (s[i] == '\\t')\n\t\t\treturn (1);\n\t\ti++;\n\t}\n\treturn (0);\n}\n",
  "GARBAGE_COLLECTOR/gc_mall.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   gc_mall.c                                          :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/14 15:43:16 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/14 15:43:16 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"../parsing.h\"\n\nstatic t_gc_node\t**get_gc_head_instance(void)\n{\n\tstatic t_gc_node\t*head;\n\n\treturn (&head);\n}\n\nvoid\tgc_add_pt(void *pt)\n{\n\tt_gc_node\t*new_node;\n\tt_gc_node\t**head;\n\n\tif (!pt)\n\t\treturn ;\n\thead = get_gc_head_instance();\n\tnew_node = (t_gc_node *)malloc(sizeof(t_gc_node));\n\tif (!new_node)\n\t{\n\t\tperror(\"malloc failed in garbage collector\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tnew_node->pt = pt;\n\tnew_node->next = *head;\n\t*head = new_node;\n}\n\nchar\t*gc_strdup(char *str)\n{\n\tchar\t*new_str;\n\n\tif (!str)\n\t\treturn (NULL);\n\tnew_str = ft_strdup(str);\n\tif (!new_str)\n\t{\n\t\tperror(\"strdup failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(new_str);\n\treturn (new_str);\n}\n\nchar\t*gc_substr(char const *s, unsigned int start, size_t len)\n{\n\tchar\t*new_str;\n\n\tif (!s)\n\t\treturn (NULL);\n\tnew_str = ft_substr(s, start, len);\n\tif (!new_str)\n\t{\n\t\tperror(\"substr failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(new_str);\n\treturn (new_str);\n}\n\nvoid\tgc_freed(void)\n{\n\tt_gc_node\t*current;\n\tt_gc_node\t*tmp;\n\tt_gc_node\t**head;\n\n\thead = get_gc_head_instance();\n\tcurrent = *head;\n\twhile (current != NULL)\n\t{\n\t\ttmp = current;\n\t\tcurrent = current->next;\n\t\tfree(tmp->pt);\n\t\tfree(tmp);\n\t}\n\t*head = NULL;\n}\n",
  "GARBAGE_COLLECTOR/gc_mall2.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   gc_mall2.c                                         :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/14 15:45:12 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/14 20:58:00 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nchar\t*gc_itoa(int n)\n{\n\tchar\t*new_str;\n\n\tnew_str = ft_itoa(n);\n\tif (!new_str)\n\t{\n\t\tperror(\"substr failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(new_str);\n\treturn (new_str);\n}\n\nvoid\t*gc_mall(size_t size)\n{\n\tvoid\t*pt;\n\n\tpt = malloc(size);\n\tif (!pt)\n\t{\n\t\tperror(\"malloc failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(pt);\n\treturn (pt);\n}\n\nchar\t*gc_strjoin(char const *s1, char const *s2)\n{\n\tchar\t*new_str;\n\n\tif (!s1 || !s2)\n\t\treturn (NULL);\n\tnew_str = ft_strjoin(s1, s2);\n\tif (!new_str)\n\t{\n\t\tperror(\"substr failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(new_str);\n\treturn (new_str);\n}\n",
  "HEREDOC/helpers.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   helpers.c                                          :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/11 08:48:29 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/08/11 08:48:29 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nchar\t*final_delim(char *delim)\n{\n\tint\ti;\n\n\ti = 0;\n\twhile (delim[i])\n\t{\n\t\tif (delim[i] == '$')\n\t\t\tbreak ;\n\t\ti++;\n\t}\n\tif (delim[i] == '$' && (delim[i + 1] == '\\'' || delim[i + 1] == '\\\"'))\n\t\tdelim[i] = '\\\"';\n\treturn (strip_quotes(delim));\n}\n\nvoid\theredoc_sigint_handler(int sig)\n{\n\t(void)sig;\n\texit(130);\n}\n\nchar\t*maybe_expand_line(char *line, bool flag, t_shell *shell)\n{\n\tint\texp;\n\n\texp = 0;\n\tif (flag)\n\t\treturn (expander(line, shell, &exp));\n\telse\n\t\treturn (gc_strdup(line));\n}\n",
  "HEREDOC/processor.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   processor.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/11 23:17:17 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/24 17:15:00 by Gemini          ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nstatic void\tchild_heredoc_routine(int *pipe_fd, t_redir *redir, t_shell *shell)\n{\n\tchar\t*line;\n\tchar\t*delimiter;\n\tchar\t*processed_line;\n\n\tsignal(SIGINT, heredoc_sigint_handler);\n\tsignal(SIGQUIT, SIG_IGN);\n\tclose(pipe_fd[0]);\n\tdelimiter = final_delim(redir->del_or_fname);\n\twhile (1)\n\t{\n\t\tline = readline(\"heredoc> \");\n\t\tif (!line || ft_strcmp(line, delimiter) == 0)\n\t\t{\n\t\t\tif (line)\n\t\t\t\tfree(line);\n\t\t\tbreak ;\n\t\t}\n\t\tprocessed_line = maybe_expand_line(line,\n\t\t\t\tredir->expand_in_heredoc, shell);\n\t\twrite(pipe_fd[1], processed_line, ft_strlen(processed_line));\n\t\t(write(pipe_fd[1], \"\\n\", 1), free(line));\n\t}\n\t(close(pipe_fd[1]), exit(0));\n}\n\nstatic int\tparent_wait_heredoc(pid_t pid, int *pipe_fd,\n\tt_redir *redir, t_shell *shell)\n{\n\tint\tstatus;\n\n\tclose(pipe_fd[1]);\n\twaitpid(pid, &status, 0);\n\tredir->heredoc_fd = pipe_fd[0];\n\tif ((WIFEXITED(status) && WEXITSTATUS(status) == 130)\n\t\t|| (WIFSIGNALED(status) && WTERMSIG(status) == SIGINT))\n\t{\n\t\tclose(pipe_fd[0]);\n\t\tredir->heredoc_fd = -1;\n\t\tshell->last_exit_status = 1;\n\t\tft_putstr_fd(\"\\n\", 2);\n\t\treturn (0);\n\t}\n\treturn (1);\n}\n\nstatic int\thandle_single_heredoc(t_redir *redir, t_shell *shell)\n{\n\tint\t\tpipe_fd[2];\n\tpid_t\tpid;\n\n\tif (pipe(pipe_fd) == -1)\n\t{\n\t\tperror(\"minishell: pipe\");\n\t\tshell->last_exit_status = 1;\n\t\treturn (0);\n\t}\n\tpid = fork();\n\tif (pid == -1)\n\t{\n\t\tperror(\"minishell: fork\");\n\t\tclose(pipe_fd[0]);\n\t\tclose(pipe_fd[1]);\n\t\tshell->last_exit_status = 1;\n\t\treturn (0);\n\t}\n\tif (pid == 0)\n\t\tchild_heredoc_routine(pipe_fd, redir, shell);\n\treturn (parent_wait_heredoc(pid, pipe_fd, redir, shell));\n}\n\nint\tprocess_heredoc_pipe(t_command *cmds_head, t_shell *shell)\n{\n\tt_command\t\t\t*cmd;\n\tt_redir\t\t\t\t*redir;\n\tstruct sigaction\tsa_orig;\n\tstruct sigaction\tsa_ign;\n\tint\t\t\t\t\tret;\n\n\tret = 1;\n\tsa_ign.sa_handler = SIG_IGN;\n\tsigemptyset(&sa_ign.sa_mask);\n\tsa_ign.sa_flags = 0;\n\tsigaction(SIGINT, &sa_ign, &sa_orig);\n\tcmd = cmds_head;\n\twhile (cmd && ret == 1)\n\t{\n\t\tredir = cmd->redirections;\n\t\twhile (redir && ret == 1)\n\t\t{\n\t\t\tif (redir->type == REDIR_HEREDOC)\n\t\t\t\tif (!handle_single_heredoc(redir, shell))\n\t\t\t\t\tret = 0;\n\t\t\tredir = redir->next;\n\t\t}\n\t\tcmd = cmd->next_piped_command;\n\t}\n\treturn (sigaction(SIGINT, &sa_orig, NULL), ret);\n}\n",
  "PARSER/error_handler.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   error_handler.c                                    :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/11 23:14:18 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/11 23:14:18 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nint\tsyntax_error_handler(char *token_value, int *status)\n{\n\tft_putstr_fd(\"minishell: syntax error near unexpected token `\", 2);\n\tif (token_value)\n\t\tft_putstr_fd(token_value, 2);\n\telse\n\t\tft_putstr_fd(\"newline\", 2);\n\tft_putstr_fd(\"'\\n\", 2);\n\t(*status) = 258;\n\treturn (0);\n}\n\nvoid\theredoc_error(void)\n{\n\tft_putstr_fd(\"minishell: maximum here-document count exceeded\\n\", 2);\n}\n",
  "PARSER/processor.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   processor.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/11 23:13:35 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/11 23:13:35 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nstatic int\tcount_args_in_segment(t_token *tokens, int *hc)\n{\n\tint\tcount;\n\n\tcount = 0;\n\twhile (tokens && tokens->type != TOKEN_PIPE && tokens->type != TOKEN_EOF)\n\t{\n\t\tif (tokens->type == TOKEN_WORD)\n\t\t\tcount++;\n\t\telse if (tokens->type >= TOKEN_REDIR_IN)\n\t\t{\n\t\t\tif (tokens->type == TOKEN_REDIR_HEREDOC)\n\t\t\t\t(*hc)++;\n\t\t\ttokens = tokens->next;\n\t\t}\n\t\tif (tokens)\n\t\t\ttokens = tokens->next;\n\t}\n\treturn (count);\n}\n\nstatic int\tprocess_cmds(t_command **command_list, t_token **tokens, int *hc,\n\t\t\t\t\t\tint *status)\n{\n\tt_command\t*current_cmd;\n\tint\t\t\ti;\n\n\tcurrent_cmd = create_command_node();\n\tadd_command_node_back(command_list, current_cmd);\n\tcurrent_cmd->args = gc_mall(sizeof(char *)\n\t\t\t* (count_args_in_segment(*tokens, hc) + 1));\n\ti = 0;\n\twhile (*tokens && (*tokens)->type != TOKEN_PIPE\n\t\t&& (*tokens)->type != TOKEN_EOF)\n\t{\n\t\tif ((*tokens)->type == TOKEN_WORD)\n\t\t{\n\t\t\tcurrent_cmd->args[i++] = gc_strdup((*tokens)->value);\n\t\t\t*tokens = (*tokens)->next;\n\t\t}\n\t\telse if ((*tokens)->type >= TOKEN_REDIR_IN)\n\t\t{\n\t\t\tif (!handle_redirection(current_cmd, tokens, status))\n\t\t\t\treturn (0);\n\t\t}\n\t}\n\tcurrent_cmd->args[i] = NULL;\n\treturn (1);\n}\n\nt_command\t*parser(t_token *tokens, int *status)\n{\n\tt_command\t*command_list;\n\tint\t\t\there_doc_c;\n\n\there_doc_c = 0;\n\tif (!tokens || tokens->type == TOKEN_EOF)\n\t\treturn (NULL);\n\tcommand_list = NULL;\n\twhile (tokens && tokens->type != TOKEN_EOF)\n\t{\n\t\tif (tokens->type == TOKEN_PIPE)\n\t\t\treturn (syntax_error_handler(tokens->value, status), NULL);\n\t\tif (!process_cmds(&command_list, &tokens, &here_doc_c, status))\n\t\t\treturn (NULL);\n\t\tif (tokens && tokens->type == TOKEN_PIPE)\n\t\t{\n\t\t\ttokens = tokens->next;\n\t\t\tif (!tokens || tokens->type == TOKEN_EOF)\n\t\t\t\treturn (syntax_error_handler(\"newline\", status), NULL);\n\t\t}\n\t}\n\tif (here_doc_c > 16)\n\t\t(heredoc_error(), exit(2));\n\treturn (command_list);\n}\n",
  "PARSER/redirections.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   redirections.c                                     :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/11 23:15:09 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/11 23:15:09 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nint\thandle_redirection(t_command *cmd, t_token **current_token_ptr, int *st)\n{\n\tt_token\t*redir_token;\n\tt_redir\t*new_redir;\n\n\tredir_token = *current_token_ptr;\n\tif (redir_token->next->type != TOKEN_WORD)\n\t{\n\t\treturn (syntax_error_handler(redir_token->next->value, st));\n\t}\n\tnew_redir = create_redir_node(redir_token->type, redir_token->next->value);\n\tadd_redir_node_back(&cmd->redirections, new_redir);\n\t*current_token_ptr = (*current_token_ptr)->next->next;\n\treturn (1);\n}\n",
  "PARSER/nodes/cmd_nodes.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   cmd_nodes.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/11 23:15:23 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/11 23:15:23 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nt_command\t*create_command_node(void)\n{\n\tt_command\t*new_cmd;\n\n\tnew_cmd = (t_command *)gc_mall(sizeof(t_command));\n\tnew_cmd->args = NULL;\n\tnew_cmd->redirections = NULL;\n\tnew_cmd->next_piped_command = NULL;\n\treturn (new_cmd);\n}\n\nvoid\tadd_command_node_back(t_command **list, t_command *new_cmd)\n{\n\tt_command\t*current;\n\n\tif (!list || !new_cmd)\n\t\treturn ;\n\tif (*list == NULL)\n\t{\n\t\t*list = new_cmd;\n\t\treturn ;\n\t}\n\tcurrent = *list;\n\twhile (current->next_piped_command != NULL)\n\t\tcurrent = current->next_piped_command;\n\tcurrent->next_piped_command = new_cmd;\n}\n",
  "PARSER/nodes/redir_nodes.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   redir_nodes.c                                      :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/11 23:15:32 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/11 23:15:32 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nstatic bool\tis_quoted(const char *str)\n{\n\tif (!str)\n\t\treturn (false);\n\twhile (*str)\n\t{\n\t\tif (*str == '\\'' || *str == '\\\"')\n\t\t\treturn (true);\n\t\tstr++;\n\t}\n\treturn (false);\n}\n\nt_redir\t*create_redir_node(t_token_type type, char *filename)\n{\n\tt_redir\t*new_redir;\n\n\tnew_redir = (t_redir *)gc_mall(sizeof(t_redir));\n\tif (type == TOKEN_REDIR_IN)\n\t\tnew_redir->type = REDIR_INPUT;\n\telse if (type == TOKEN_REDIR_OUT)\n\t\tnew_redir->type = REDIR_OUTPUT_TRUNC;\n\telse if (type == TOKEN_REDIR_APPEND)\n\t\tnew_redir->type = REDIR_OUTPUT_APPEND;\n\telse if (type == TOKEN_REDIR_HEREDOC)\n\t\tnew_redir->type = REDIR_HEREDOC;\n\tnew_redir->del_or_fname = gc_strdup(filename);\n\tnew_redir->heredoc_fd = -1;\n\tnew_redir->expand_in_heredoc = !is_quoted(filename);\n\tnew_redir->next = NULL;\n\treturn (new_redir);\n}\n\nvoid\tadd_redir_node_back(t_redir **list, t_redir *new_redir)\n{\n\tt_redir\t*current;\n\n\tif (!list || !new_redir)\n\t\treturn ;\n\tif (*list == NULL)\n\t{\n\t\t*list = new_redir;\n\t\treturn ;\n\t}\n\tcurrent = *list;\n\twhile (current->next != NULL)\n\t\tcurrent = current->next;\n\tcurrent->next = new_redir;\n}\n",
  "TOKENIZER/nodes.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   nodes.c                                            :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/06 19:17:32 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/06 19:17:32 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nt_token\t*create_token(t_token_type type, char *value)\n{\n\tt_token\t*new_token;\n\n\tnew_token = (t_token *)gc_mall(sizeof(t_token));\n\tnew_token->type = type;\n\tif (value)\n\t\tnew_token->value = gc_strdup(value);\n\telse\n\t\tnew_token->value = NULL;\n\tnew_token->next = NULL;\n\treturn (new_token);\n}\n\nvoid\tadd_token_back(t_token **list, t_token *new_token)\n{\n\tt_token\t*current;\n\n\tif (!list || !new_token)\n\t\treturn ;\n\tif (*list == NULL)\n\t{\n\t\t*list = new_token;\n\t\treturn ;\n\t}\n\tcurrent = *list;\n\twhile (current->next != NULL)\n\t{\n\t\tcurrent = current->next;\n\t}\n\tcurrent->next = new_token;\n}\n",
  "TOKENIZER/operators.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   operators.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/06 19:11:58 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/06 19:11:58 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nt_token\t*get_operator_token(char *line, int *i)\n{\n\tif (line[*i] == '|')\n\t\treturn ((*i)++, create_token(TOKEN_PIPE, \"|\"));\n\tif (line[*i] == '>')\n\t{\n\t\t(*i)++;\n\t\tif (line[*i] == '>')\n\t\t\treturn ((*i)++, create_token(TOKEN_REDIR_APPEND, \">>\"));\n\t\treturn (create_token(TOKEN_REDIR_OUT, \">\"));\n\t}\n\tif (line[*i] == '<')\n\t{\n\t\t(*i)++;\n\t\tif (line[*i] == '<')\n\t\t\treturn ((*i)++, create_token(TOKEN_REDIR_HEREDOC, \"<<\"));\n\t\treturn (create_token(TOKEN_REDIR_IN, \"<\"));\n\t}\n\treturn (NULL);\n}\n",
  "TOKENIZER/tokenizer.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   tokenizer.c                                        :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/06 19:15:46 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/06 19:16:10 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nstatic int\tprocess_line_segment(t_token **tokens, char *line, int *i,\n\t\tint *status)\n{\n\tt_token\t*new_token;\n\n\tif (line[*i] == '$' && (line[*i + 1] == '\\\"' || line[*i + 1] == '\\''))\n\t\t(*i)++;\n\tif (is_metachar(line[*i]))\n\t\tnew_token = get_operator_token(line, i);\n\telse\n\t\tnew_token = get_word_token(line, i, status);\n\tif (new_token == NULL)\n\t\treturn (1);\n\tif (new_token != (void *)1)\n\t\tadd_token_back(tokens, new_token);\n\treturn (0);\n}\n\nt_token\t*tokenizer(char *line, int *status)\n{\n\tt_token\t*tokens;\n\tint\t\ti;\n\n\ttokens = NULL;\n\ti = 0;\n\twhile (line[i])\n\t{\n\t\tif (ft_isspace(line[i]))\n\t\t{\n\t\t\ti++;\n\t\t\tcontinue ;\n\t\t}\n\t\tif (process_line_segment(&tokens, line, &i, status))\n\t\t\treturn (NULL);\n\t}\n\tadd_token_back(&tokens, create_token(TOKEN_EOF, NULL));\n\treturn (tokens);\n}\n",
  "TOKENIZER/tools.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   tools.c                                            :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/06 19:19:15 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/06 19:19:15 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nint\tft_isspace(char c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\n' || \\\n\t\t\tc == '\\v' || c == '\\f' || c == '\\r');\n}\n\nint\tis_metachar(char c)\n{\n\treturn (c == '|' || c == '<' || c == '>');\n}\n\nint\tis_unsupported_metachar(char c)\n{\n\tif (c == ';' || c == '\\\\' || c == '&' || c == '(' || c == ')' || \\\n\t\tc == '{' || c == '}')\n\t\treturn (1);\n\treturn (0);\n}\n",
  "TOKENIZER/words.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   words.c                                            :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/07/06 19:13:51 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/07/06 19:13:56 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nstatic char\t*extract_quoted_part(char *line, int *i, int *status)\n{\n\tchar\tquote_char;\n\tint\t\tstart;\n\n\tquote_char = line[*i];\n\tstart = *i;\n\t(*i)++;\n\twhile (line[*i] && line[*i] != quote_char)\n\t\t(*i)++;\n\tif (line[*i] == '\\0')\n\t{\n\t\tft_putstr_fd(\"minishell: syntax error: unclosed quote\\n\", 2);\n\t\t(*status) = 258;\n\t\treturn (NULL);\n\t}\n\t(*i)++;\n\treturn (gc_substr(line, start, *i - start));\n}\n\nstatic char\t*extract_unquoted_part(char *line, int *i)\n{\n\tint\tstart;\n\n\tstart = *i;\n\twhile (line[*i] && !ft_isspace(line[*i]) && !is_metachar(line[*i])\n\t\t&& line[*i] != '\\'' && line[*i] != '\"')\n\t\t(*i)++;\n\treturn (gc_substr(line, start, *i - start));\n}\n\nt_token\t*get_word_token(char *line, int *i, int *status)\n{\n\tchar\t*word_so_far;\n\tchar\t*next_part;\n\tchar\t*temp;\n\n\tword_so_far = gc_strdup(\"\");\n\tif (!word_so_far)\n\t\treturn (NULL);\n\twhile (line[*i] && !ft_isspace(line[*i]) && !is_metachar(line[*i]))\n\t{\n\t\tif (line[*i] == '\\'' || line[*i] == '\"')\n\t\t\tnext_part = extract_quoted_part(line, i, status);\n\t\telse\n\t\t\tnext_part = extract_unquoted_part(line, i);\n\t\tif (!next_part)\n\t\t\treturn (NULL);\n\t\ttemp = word_so_far;\n\t\tword_so_far = gc_strjoin(temp, next_part);\n\t}\n\tif (ft_strlen(word_so_far) == 0)\n\t\treturn ((void *)1);\n\treturn (create_token(TOKEN_WORD, word_so_far));\n}\n",
  "tools/strings.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   strings.c                                          :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/11 11:36:53 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/08/11 11:36:53 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nint\tft_isalpha(int c)\n{\n\treturn ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'));\n}\n\nint\tft_isalnum(int c)\n{\n\treturn (ft_isalpha(c) || (c >= '0' && c <= '9'));\n}\n\nchar\t*ft_strdup(char *value)\n{\n\tchar\t*result;\n\tint\t\ti;\n\tint\t\tlen;\n\n\tif (!value)\n\t\treturn (NULL);\n\tlen = ft_strlen(value);\n\tresult = malloc(sizeof(char) * (len + 1));\n\tif (!result)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (value[i] != '\\0')\n\t{\n\t\tresult[i] = value[i];\n\t\ti++;\n\t}\n\tresult[i] = '\\0';\n\treturn (result);\n}\n\nsize_t\tft_strlen(const char *s)\n{\n\tsize_t\ti;\n\n\ti = 0;\n\tif (!s)\n\t\treturn (0);\n\twhile (s[i])\n\t\ti++;\n\treturn (i);\n}\n\nchar\t*ft_substr(char const *s, unsigned int start, size_t len)\n{\n\tsize_t\ti;\n\tchar\t*r;\n\tsize_t\ts_len;\n\n\tif (!s)\n\t\treturn (NULL);\n\ts_len = ft_strlen(s);\n\tif (s_len < start)\n\t\treturn (gc_strdup(\"\"));\n\tif (len > s_len - start)\n\t\tlen = s_len - start;\n\tr = malloc(len + 1);\n\tif (!r)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (i < len)\n\t{\n\t\tr[i] = s[start + i];\n\t\ti++;\n\t}\n\tr[i] = '\\0';\n\treturn (r);\n}\n",
  "tools/strings1.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   strings1.c                                         :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/11 08:56:14 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/08/11 08:59:24 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nstatic int\tcount_digits(int n)\n{\n\tint\tcount;\n\n\tcount = 1;\n\twhile (n / 10)\n\t{\n\t\tn /= 10;\n\t\tcount++;\n\t}\n\treturn (count);\n}\n\nchar\t*ft_itoa(int n)\n{\n\tchar\t\t*str;\n\tlong\t\tnum;\n\tint\t\t\tlen;\n\tint\t\t\tis_negative;\n\n\tnum = n;\n\tis_negative = (num < 0);\n\tif (is_negative)\n\t\tnum = -num;\n\tlen = count_digits(num) + is_negative;\n\tstr = malloc(sizeof(char) * (len + 1));\n\tif (!str)\n\t\treturn (NULL);\n\tstr[len] = '\\0';\n\twhile (len-- > 0)\n\t{\n\t\tstr[len] = '0' + (num % 10);\n\t\tnum /= 10;\n\t\tif (len == 0 && is_negative)\n\t\t\tstr[0] = '-';\n\t}\n\treturn (str);\n}\n\nint\tft_atoi(const char *str)\n{\n\tint\t\ti;\n\tint\t\tsign;\n\tlong\tresult;\n\n\ti = 0;\n\tsign = 1;\n\tresult = 0;\n\twhile (str[i] == ' ' || (str[i] >= '\\t' && str[i] <= '\\r'))\n\t\ti++;\n\tif (str[i] == '-' || str[i] == '+')\n\t{\n\t\tif (str[i] == '-')\n\t\t\tsign = -1;\n\t\ti++;\n\t}\n\twhile (str[i] >= '0' && str[i] <= '9')\n\t{\n\t\tresult = result * 10 + (str[i] - '0');\n\t\ti++;\n\t}\n\treturn ((int)(result * sign));\n}\n\nchar\t*ft_strchr(const char *s, int c)\n{\n\twhile (*s)\n\t{\n\t\tif (*s == (char)c)\n\t\t\treturn ((char *)s);\n\t\ts++;\n\t}\n\tif ((char)c == '\\0')\n\t\treturn ((char *)s);\n\treturn (NULL);\n}\n\nvoid\tft_putstr_fd(const char *s, int fd)\n{\n\tif (s)\n\t\twrite(fd, s, ft_strlen(s));\n}\n",
  "tools/strings2.c": "/* ************************************************************************** */\n/*                                                                            */\n/*                                                        :::      ::::::::   */\n/*   strings2.c                                         :+:      :+:    :+:   */\n/*                                                    +:+ +:+         +:+     */\n/*   By: oben-jha <oben-jha@student.42.fr>          +#+  +:+       +#+        */\n/*                                                +#+#+#+#+#+   +#+           */\n/*   Created: 2025/08/11 08:57:55 by oben-jha          #+#    #+#             */\n/*   Updated: 2025/08/11 11:52:44 by oben-jha         ###   ########.fr       */\n/*                                                                            */\n/* ************************************************************************** */\n\n#include \"parsing.h\"\n\nstatic size_t\tcount_words(char const *s, char c)\n{\n\tsize_t\tcount;\n\tsize_t\ti;\n\n\tcount = 0;\n\ti = 0;\n\twhile (s && s[i])\n\t{\n\t\tif (s[i] != c)\n\t\t{\n\t\t\tcount++;\n\t\t\twhile (s[i] && s[i] != c)\n\t\t\t\ti++;\n\t\t}\n\t\telse\n\t\t\ti++;\n\t}\n\treturn (count);\n}\n\nchar\t**ft_split(char const *s, char c)\n{\n\tchar\t**arr;\n\tsize_t\ti;\n\tsize_t\tj;\n\tsize_t\tstart;\n\n\tif (!s)\n\t\treturn (NULL);\n\tarr = (char **)gc_mall(sizeof(char *) * (count_words(s, c) + 1));\n\tif (!arr)\n\t\treturn (NULL);\n\ti = 0;\n\tj = 0;\n\twhile (s[i])\n\t{\n\t\tif (s[i] != c)\n\t\t{\n\t\t\tstart = i;\n\t\t\twhile (s[i] && s[i] != c)\n\t\t\t\ti++;\n\t\t\tarr[j++] = gc_substr(s, start, i - start);\n\t\t}\n\t\telse\n\t\t\ti++;\n\t}\n\tarr[j] = NULL;\n\treturn (arr);\n}\n\nchar\t*ft_strjoin(char const *s1, char const *s2)\n{\n\tchar\t*new_str;\n\tsize_t\ti;\n\tsize_t\tj;\n\n\tif (!s1 || !s2)\n\t\treturn (NULL);\n\tnew_str = (char *)malloc(ft_strlen(s1) + ft_strlen(s2) + 1);\n\tif (!new_str)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (s1[i])\n\t{\n\t\tnew_str[i] = s1[i];\n\t\ti++;\n\t}\n\tj = 0;\n\twhile (s2[j])\n\t{\n\t\tnew_str[i + j] = s2[j];\n\t\tj++;\n\t}\n\tnew_str[i + j] = '\\0';\n\treturn (new_str);\n}\n\nint\tft_strcmp(const char *s1, const char *s2)\n{\n\tsize_t\ti;\n\n\ti = 0;\n\twhile (s1[i] && s2[i] && s1[i] == s2[i])\n\t\ti++;\n\treturn ((unsigned char)s1[i] - (unsigned char)s2[i]);\n}\n\nint\tft_strncmp(const char *s1, const char *s2, size_t n)\n{\n\tsize_t\ti;\n\n\ti = 0;\n\tif (n == 0)\n\t\treturn (0);\n\twhile (i < n - 1 && s1[i] && s2[i] && s1[i] == s2[i])\n\t\ti++;\n\treturn ((unsigned char)s1[i] - (unsigned char)s2[i]);\n}\n"
}