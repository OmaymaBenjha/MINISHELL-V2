{
  "main.c": "#include \"parsing.h\"\n\nvoid\tprint_commands(t_command *list)\n{\n\tt_command\t*cmd;\n\tt_redir\t\t*redir;\n\tint\t\t\ti;\n\tint\t\t\tj;\n\n\tcmd = list;\n\ti = 1;\n\twhile (cmd)\n\t{\n\t\tprintf(\"\\n--- Command %d ---\\n\", i++);\n\t\tj = 0;\n\t\tif (cmd->args)\n\t\t{\n\t\t\twhile (cmd->args[j])\n\t\t\t{\n\t\t\t\tprintf(\"  args[%d]: [%s]\\n\", j, cmd->args[j]);\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tprintf(\"  args: (null)\\n\");\n\t\t}\n\t\tredir = cmd->redirections;\n\t\tif (redir)\n\t\t{\n\t\t\tj = 1;\n\t\t\twhile (redir)\n\t\t\t{\n\t\t\t\tprintf(\"  Redir %d -> Type: %d, File: [%s]\\n\", j++, redir->type,\n\t\t\t\t\tredir->delimiter_or_filename);\n\t\t\t\tredir = redir->next;\n\t\t\t}\n\t\t}\n\t\tcmd = cmd->next_piped_command;\n\t\tif (cmd)\n\t\t{\n\t\t\tprintf(\"    |\\n\");\n\t\t\tprintf(\"    V\\n\");\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}\n\nint\tmain(int ac, char **arg, char **env)\n{\n\tchar\t\t*input_line;\n\tt_token\t\t*tokens;\n\tt_command\t*commands;\n\n\t(void)ac;\n\t(void)arg;\n\twhile (1)\n\t{\n\t\tinput_line = readline(\"minishell> \");\n\t\tif (!input_line)\n\t\t{\n\t\t\tprintf(\"exit\\n\");\n\t\t\tbreak ;\n\t\t}\n\t\tif (input_line[0] != '\\0')\n\t\t{\n\t\t\tadd_history(input_line);\n\t\t\ttokens = tokenizer(input_line);\n\t\t\tif (tokens)\n\t\t\t{\n\t\t\t\tcommands = parser(tokens);\n\t\t\t\tif (commands)\n\t\t\t\t{\n\t\t\t\t\t// heredoc, in order to expand it , the delimiter shouldn't be quoted at all\n\t\t\t\t\tif (process_heredoc_pipe(commands, env))\n\t\t\t\t\t{\n\t\t\t\t\t// None heredoc cases , i  order to expand it, filenames and args shouln't be \n\t\t\t\t\t// single quoted \n\t\t\t\t\t\tglobal_expand(commands, env);\n\t\t\t\t\t\tquote_remover(commands);\n\t\t\t\t\t\t// executor(commands);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfree(input_line);\n\t\tgc_freed();\n\t}\n\tgc_freed();\n\treturn (0);\n}\n",
  "Makefile": "NAME = minishell\nCC = gcc\nCFLAGS = -Wall -Wextra -Werror -fsanitize=address -g\nRM = rm -f\n\nSRCS =\tmain.c \\\n\t\tTOKENIZER/tokenizer.c \\\n\t\tTOKENIZER/tools.c \\\n\t\tTOKENIZER/nodes.c \\\n\t\tTOKENIZER/words.c \\\n\t\tTOKENIZER/operators.c \\\n\t\tTOOLS/strings.c \\\n\t\tPARSER/nodes/cmd_nodes.c \\\n\t\tPARSER/error_handler.c \\\n\t\tPARSER/processor.c \\\n\t\tPARSER/redirections.c \\\n\t\tPARSER/nodes/redir_nodes.c \\\n\t\tGARBAGE_COLLECTOR/gc_mall.c \\\n\t\tHEREDOC/processor.c \\\n\t\tEXPAND/expand.c \\\n\t\tEXPAND/quotes_removal.c \\\n\t\tEXPAND/utils.c \\\n\t\tEXPAND/g_expand.c\n\nOBJS = $(SRCS:.c=.o)\n\nall: $(NAME)\n\n$(NAME): $(OBJS)\n\t$(CC) $(CFLAGS) -o $(NAME) $(OBJS) -lreadline\n\n%.o: %.c\n\t$(CC) $(CFLAGS) -I. -c $< -o $@\n\nclean:\n\t$(RM) $(OBJS)\n\nfclean: clean\n\t$(RM) $(NAME)\n\nre: fclean all\n\n.PHONY: all clean fclean re\n",
  "parsing.h": "#ifndef PARSING_H\n# define PARSING_H\n\n# include <stdlib.h>\n# include <stddef.h>\n# include <stdio.h>\n# include <stdbool.h>\n# include <unistd.h>\n# include <readline/readline.h>\n# include <readline/history.h>\n# include <signal.h>\n# include <sys/wait.h>\n\ntypedef struct s_gc_node\n{\n\tvoid\t\t\t\t*pt;\n\tstruct s_gc_node\t*next;\n}\tt_gc_node;\n\ntypedef enum e_token_type\n{\n\tTOKEN_WORD,\n\tTOKEN_PIPE,\n\tTOKEN_REDIR_IN,\n\tTOKEN_REDIR_OUT,\n\tTOKEN_REDIR_APPEND,\n\tTOKEN_REDIR_HEREDOC,\n\tTOKEN_NEWLINE,\n\tTOKEN_EOF,\n\tTOKEN_ERROR\n}\tt_token_type;\n\ntypedef struct s_token\n{\n\tt_token_type\ttype;\n\tchar\t\t\t*value;\n\tstruct s_token\t*next;\n}\tt_token;\n\ntypedef enum e_redir_type\n{\n\tREDIR_NONE,\n\tREDIR_INPUT,\n\tREDIR_OUTPUT_TRUNC,\n\tREDIR_OUTPUT_APPEND,\n\tREDIR_HEREDOC\n}\tt_redir_type;\n\ntypedef struct s_redir\n{\n\tt_redir_type\ttype;\n\tchar\t\t\t*delimiter_or_filename;\n\tint\t\t\t\theredoc_fd;\n\tbool\t\t\texpand_in_heredoc;\n\tstruct s_redir\t*next;\n}\tt_redir;\n\ntypedef struct s_command\n{\n\tchar\t\t\t\t**args;\n\tt_redir\t\t\t\t*redirections;\n\tstruct s_command\t*next_piped_command;\n}\tt_command;\n\nvoid\t\tgc_add_pt(void *pt);\nvoid\t\t*gc_mall(size_t size);\nchar\t\t*gc_strdup(char *str);\nvoid\t\tgc_freed(void);\n\n// TOKENIZER PROTOTYPES\nt_token\t\t*tokenizer(char *line);\nt_token\t\t*create_token(t_token_type type, char *value);\nvoid\t\tadd_token_back(t_token **list, t_token *new_token);\nt_token\t\t*get_operator_token(char *line, int *i);\nt_token\t\t*get_word_token(char *line, int *i);\n\n// PARSER PROTOTYPES\nt_command\t*parser(t_token *tokens);\nint\t\t\tsyntax_error_handler(char *token_value);\nt_command\t*create_command_node(void);\nvoid\t\tadd_command_node_back(t_command **list, t_command *new_cmd);\nt_redir\t\t*create_redir_node(t_token_type type, char *filename);\nvoid\t\tadd_redir_node_back(t_redir **list, t_redir *new_redir);\nint\t\t\thandle_redirection(t_command *cmd, t_token **current_token);\n\n// HEREDOC PROTOTYPES\nint\t\t\tprocess_heredoc_pipe(t_command *cmds_head, char **env);\n\n// EXPAND PROTOTYPES\nchar\t\t*expander(char *str, char **env);\nvoid\t\tquote_remover(t_command *cmd_list);\nchar\t\t*strip_quotes(const char *str);\nvoid\t\tglobal_expand(t_command *cmds_head, char **env);\n\n// --- MISSING PROTOTYPES ADDED HERE ---\n// TOOLS/STRINGS PROTOTYPES\nchar\t\t*ft_strdup(char *value);\nint\t\t\tft_strncmp(const char *s1, const char *s2, size_t n);\nsize_t\t\tft_strlen(const char *s);\nvoid\t\tft_putstr_fd(const char *s, int fd);\nchar\t\t*ft_substr(char const *s, unsigned int start, size_t len);\nchar\t\t*ft_strjoin(char const *s1, char const *s2);\nint\t\t\tft_isalpha(int c);\nint\t\t\tft_isalnum(int c);\nchar\t\t*ft_itoa(int n);\n\n// TOOLS/CHECKERS PROTOTYPES\nint\t\t\tft_isspace(char c);\nint\t\t\tis_metachar(char c);\nint\t\t\tis_unsupported_metachar(char c);\n\n#endif",
  "EXPAND/expand.c": "#include \"parsing.h\"\n#include <stdlib.h>\n\nstatic void\tappend_char(char **s, char c)\n{\n\tchar\t*temp;\n\tchar\tto_append[2];\n\n\tto_append[0] = c;\n\tto_append[1] = '\\0';\n\ttemp = *s;\n\t*s = ft_strjoin(temp, to_append);\n\tfree(temp);\n}\n\nstatic char\t*extract_variable_name(const char *str)\n{\n\tint\ti;\n\n\ti = 0;\n\tif (ft_isalpha(str[i]) || str[i] == '_')\n\t{\n\t\ti++;\n\t\twhile (ft_isalnum(str[i]) || str[i] == '_')\n\t\t\ti++;\n\t}\n\treturn (ft_substr(str, 0, i));\n}\n\nstatic void\thandle_dollar_expansion(char **new_str, const char *str, int *i,\n\t\tchar **env)\n{\n\tchar\t*key;\n\tchar\t*value;\n\tchar\t*temp_str;\n\tchar\t*temp_join;\n\n\t(void)env;\n\t(*i)++;\n\tif (str[*i] == '?')\n\t{\n\t\ttemp_str = ft_itoa(0);\n\t\ttemp_join = *new_str;\n\t\t*new_str = ft_strjoin(temp_join, temp_str);\n\t\tfree(temp_join);\n\t\tfree(temp_str);\n\t\t(*i)++;\n\t\treturn ;\n\t}\n\tkey = extract_variable_name(&str[*i]);\n\tif (!key || *key == '\\0')\n\t{\n\t\tappend_char(new_str, '$');\n\t\tfree(key);\n\t\treturn ;\n\t}\n\tvalue = getenv(key);\n\tif (value)\n\t{\n\t\ttemp_join = *new_str;\n\t\t*new_str = ft_strjoin(temp_join, value);\n\t\tfree(temp_join);\n\t}\n\t*i += ft_strlen(key);\n\tfree(key);\n}\n\nchar\t*expander(char *str, char **env)\n{\n\tchar\t*new_str;\n\tint\t\ti;\n\n\tif (!str)\n\t\treturn (NULL);\n\tnew_str = ft_strdup(\"\");\n\ti = 0;\n\twhile (str[i])\n\t{\n\t\tif (str[i] == '$')\n\t\t\thandle_dollar_expansion(&new_str, str, &i, env);\n\t\telse\n\t\t{\n\t\t\tappend_char(&new_str, str[i]);\n\t\t\ti++;\n\t\t}\n\t}\n\tgc_add_pt(new_str);\n\treturn (new_str);\n}",
  "EXPAND/g_expand.c": "#include \"parsing.h\"\n\nstatic bool\tis_single_quoted(const char *str)\n{\n\tsize_t\tlen;\n\n\tif (!str)\n\t\treturn (false);\n\tlen = ft_strlen(str);\n\tif (len < 2)\n\t\treturn (false);\n\tif (str[0] == '\\'' && str[len - 1] == '\\'')\n\t\treturn (true);\n\treturn (false);\n}\n\nvoid\tglobal_expand(t_command *cmds_head, char **env)\n{\n\tt_command\t*cmd;\n\tt_redir\t\t*redir;\n\tint\t\t\ti;\n\n\tcmd = cmds_head;\n\twhile (cmd)\n\t{\n\t\ti = 0;\n\t\twhile (cmd->args && cmd->args[i])\n\t\t{\n\t\t\tif (!is_single_quoted(cmd->args[i]))\n\t\t\t\tcmd->args[i] = expander(cmd->args[i], env);\n\t\t\ti++;\n\t\t}\n\t\tredir = cmd->redirections;\n\t\twhile (redir)\n\t\t{\n\t\t\tif (redir->type != REDIR_HEREDOC\n\t\t\t\t&& !is_single_quoted(redir->delimiter_or_filename))\n\t\t\t\tredir->delimiter_or_filename = expander(redir->delimiter_or_filename,\n\t\t\t\t\t\tenv);\n\t\t\tredir = redir->next;\n\t\t}\n\t\tcmd = cmd->next_piped_command;\n\t}\n}",
  "EXPAND/quotes_removal.c": "#include \"parsing.h\"\nstatic void\tclean_quotes_in_args(t_command *cmd)\n{\n\tint\t\ti;\n\tchar\t*stripped;\n\n\ti = 0;\n\tif (!cmd || !cmd->args)\n\t\treturn ;\n\twhile (cmd->args[i])\n\t{\n\t\tstripped = strip_quotes(cmd->args[i]);\n\t\tif (stripped)\n\t\t\tcmd->args[i] = stripped;\n\t\ti++;\n\t}\n}\n\nstatic void\tclean_quotes_in_redirs(t_command *cmd)\n{\n\tt_redir\t*redir;\n\tchar\t*stripped;\n\n\tif (!cmd)\n\t\treturn ;\n\tredir = cmd->redirections;\n\twhile (redir)\n\t{\n\t\tif (redir->type)\n\t\t{\n\t\t\tstripped = strip_quotes(redir->delimiter_or_filename);\n\t\t\tif (stripped)\n\t\t\t\tredir->delimiter_or_filename = stripped;\n\t\t}\n\t\tredir = redir->next;\n\t}\n}\n\nvoid\tquote_remover(t_command *cmd_list)\n{\n\twhile (cmd_list)\n\t{\n\t\tclean_quotes_in_args(cmd_list);\n\t\tclean_quotes_in_redirs(cmd_list);\n\t\tcmd_list = cmd_list->next_piped_command;\n\t}\n}",
  "EXPAND/utils.c": "#include \"parsing.h\" \n\nstatic size_t\tcount_stripped_len(const char *str)\n{\n\tsize_t\ti;\n\tsize_t\tlen;\n\tbool\tin_squote;\n\tbool\tin_dquote;\n\n\ti = 0;\n\tlen = 0;\n\tin_squote = false;\n\tin_dquote = false;\n\twhile (str[i])\n\t{\n\t\tif (str[i] == '\\'' && !in_dquote)\n\t\t\tin_squote = !in_squote;\n\t\telse if (str[i] == '\\\"' && !in_squote)\n\t\t\tin_dquote = !in_dquote;\n\t\telse\n\t\t\tlen++;\n\t\ti++;\n\t}\n\treturn (len);\n}\n\nchar    *strip_quotes(const char *str)\n{\n\tsize_t\ti;\n\tsize_t\tj;\n\tchar\t*cleaned;\n\tbool\tin_squote;\n\tbool\tin_dquote;\n\n\tif (!str)\n\t\treturn (NULL);\n\tcleaned = gc_mall(count_stripped_len(str) + 1);\n\tif (!cleaned)\n\t\treturn (NULL);\n\ti = 0;\n\tj = 0;\n\tin_squote = false;\n\tin_dquote = false;\n\twhile (str[i])\n\t{\n\t\tif (str[i] == '\\'' && !in_dquote)\n\t\t\tin_squote = !in_squote;\n\t\telse if (str[i] == '\\\"' && !in_squote)\n\t\t\tin_dquote = !in_dquote;\n\t\telse\n\t\t\tcleaned[j++] = str[i];\n\t\ti++;\n\t}\n\tcleaned[j] = '\\0';\n\treturn (cleaned);\n}\n\nstatic int\tcount_digits(int n)\n{\n\tint\tcount = 1;\n\n\twhile (n / 10)\n\t{\n\t\tn /= 10;\n\t\tcount++;\n\t}\n\treturn (count);\n}\n\nchar\t*ft_itoa(int n)\n{\n\tchar\t\t*str;\n\tlong\t\tnum;\n\tint\t\t\tlen;\n\tint\t\t\tis_negative;\n\n\tnum = n;\n\tis_negative = (num < 0);\n\tif (is_negative)\n\t\tnum = -num;\n\tlen = count_digits(num) + is_negative;\n\tstr = malloc(sizeof(char) * (len + 1));\n\tif (!str)\n\t\treturn (NULL);\n\tstr[len] = '\\0';\n\twhile (len-- > 0)\n\t{\n\t\tstr[len] = '0' + (num % 10);\n\t\tnum /= 10;\n\t\tif (len == 0 && is_negative)\n\t\t\tstr[0] = '-';\n\t}\n\treturn (str);\n}\n",
  "GARBAGE_COLLECTOR/gc_mall.c": "#include \"../parsing.h\"\n\nstatic t_gc_node\t*g_gc_head = NULL;\n\nvoid\tgc_add_pt(void *pt)\n{\n\tt_gc_node\t*new_node;\n\n\tif (!pt) \n\t\treturn;\n\tnew_node = (t_gc_node *)malloc(sizeof(t_gc_node));\n\tif (!new_node)\n\t{\n\t\tperror(\"malloc failed in garbage collector\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tnew_node->pt = pt;\n\tnew_node->next = g_gc_head;\n\tg_gc_head = new_node;\n}\n\nchar\t*gc_strdup(char *str)\n{\n\tchar\t*new_str;\n\n\tif (!str)\n\t\treturn (NULL);\n\tnew_str = ft_strdup(str);\n\tif (!new_str)\n\t{\n\t\tperror(\"strdup failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(new_str);\n\treturn (new_str);\n}\n\nvoid\t*gc_mall(size_t size)\n{\n\tvoid\t*pt;\n\n\tpt = malloc(size);\n\tif (!pt)\n\t{\n\t\tperror(\"malloc failed!\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tgc_add_pt(pt);\n\treturn (pt);\n}\n\nvoid\tgc_freed(void)\n{\n\tt_gc_node\t*current;\n\tt_gc_node\t*tmp;\n\n\tcurrent = g_gc_head;\n\twhile (current != NULL)\n\t{\n\t\ttmp = current;\n\t\tcurrent = current->next;\n\t\tfree(tmp->pt); \n\t\tfree(tmp);\n\t}\n\tg_gc_head = NULL;\n}",
  "HEREDOC/processor.c": "#include \"parsing.h\"\n\nstatic char\t*maybe_expand_line(char *line, bool flag, char **env)\n{\n\tchar\t*new_str;\n\n\tif (flag == true)\n\t\tnew_str = expander(line, env);\n\telse\n\t\tnew_str = ft_strdup(line);\n\tif (new_str == line)\n\t\tnew_str = ft_strdup(line);\n\treturn (new_str);\n}\n\nint\tprocess_heredoc_pipe(t_command *cmds_head, char **env)\n{\n\tt_command\t*cmd;\n\tt_redir\t\t*redir;\n\tint\t\t\tfd[2];\n\tchar\t\t*line;\n\tchar\t\t*processed_line;\n\tchar\t\t*delimiter;\n\n\tcmd = cmds_head;\n\twhile (cmd)\n\t{\n\t\tredir = cmd->redirections;\n\t\twhile (redir)\n\t\t{\n\t\t\tif (redir->type == REDIR_HEREDOC)\n\t\t\t{\n\t\t\t\tif (pipe(fd) == -1)\n\t\t\t\t\treturn (perror(\"pipe\"), 0);\n\t\t\t\tdelimiter = strip_quotes(redir->delimiter_or_filename);\n\t\t\t\twhile (1)\n\t\t\t\t{\n\t\t\t\t\tline = readline(\"heredoc> \");\n\t\t\t\t\tif (!line || (ft_strlen(line) == ft_strlen(delimiter)\n\t\t\t\t\t\t&& ft_strncmp(line, delimiter, ft_strlen(line)) == 0))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (line)\n\t\t\t\t\t\t\tfree(line);\n\t\t\t\t\t\tbreak ;\n\t\t\t\t\t}\n\t\t\t\t\tprocessed_line = maybe_expand_line(line, redir->expand_in_heredoc, env);\n\t\t\t\t\twrite(fd[1], processed_line, ft_strlen(processed_line));\n\t\t\t\t\twrite(fd[1], \"\\n\", 1);\n\t\t\t\t\tfree(line);\n\t\t\t\t\tfree(processed_line);\n\t\t\t\t}\n\t\t\t\tclose(fd[1]);\n\t\t\t\tredir->heredoc_fd = fd[0];\n\t\t\t}\n\t\t\tredir = redir->next;\n\t\t}\n\t\tcmd = cmd->next_piped_command;\n\t}\n\treturn (1);\n}",
  "PARSER/error_handler.c": "#include \"parsing.h\"\n\nint\tsyntax_error_handler(char *token_value)\n{\n\tft_putstr_fd(\"minishell: syntax error near unexpected token `\", 2);\n\tif (token_value)\n\t\tft_putstr_fd(token_value, 2);\n\telse\n\t\tft_putstr_fd(\"newline\", 2);\n\tft_putstr_fd(\"'\\n\", 2);\n\treturn (0);\n}",
  "PARSER/heredoc.c": "",
  "PARSER/processor.c": "#include \"parsing.h\"\n\nstatic int\tcount_args_in_segment(t_token *tokens)\n{\n\tint\tcount;\n\n\tcount = 0;\n\twhile (tokens && tokens->type != TOKEN_PIPE && tokens->type != TOKEN_EOF)\n\t{\n\t\tif (tokens->type == TOKEN_WORD)\n\t\t\tcount++;\n\t\telse if (tokens->type >= TOKEN_REDIR_IN)\n\t\t\ttokens = tokens->next;\n\t\tif (tokens)\n\t\t\ttokens = tokens->next;\n\t}\n\treturn (count);\n}\n\nt_command\t*parser(t_token *tokens)\n{\n\tt_command\t*command_list;\n\tt_command\t*current_cmd;\n\tt_token\t\t*current_token;\n\tint\t\t\ti;\n\n\tif (!tokens || tokens->type == TOKEN_EOF)\n\t\treturn (NULL);\n\tcommand_list = NULL;\n\tcurrent_token = tokens;\n\twhile (current_token && current_token->type != TOKEN_EOF)\n\t{\n\t\tif (current_token->type == TOKEN_PIPE)\n\t\t\treturn (syntax_error_handler(current_token->value), NULL);\n\t\tcurrent_cmd = create_command_node();\n\t\tadd_command_node_back(&command_list, current_cmd);\n\t\tcurrent_cmd->args = gc_mall(sizeof(char *) * \\\n\t\t\t(count_args_in_segment(current_token) + 1));\n\t\ti = 0;\n\t\twhile (current_token && current_token->type != TOKEN_PIPE \\\n\t\t\t&& current_token->type != TOKEN_EOF)\n\t\t{\n\t\t\tif (current_token->type == TOKEN_WORD)\n\t\t\t{\n\t\t\t\tcurrent_cmd->args[i++] = gc_strdup(current_token->value);\n\t\t\t\tcurrent_token = current_token->next;\n\t\t\t}\n\t\t\telse if (current_token->type >= TOKEN_REDIR_IN)\n\t\t\t{\n\t\t\t\tif (!handle_redirection(current_cmd, &current_token))\n\t\t\t\t\treturn (NULL);\n\t\t\t}\n\t\t}\n\t\tcurrent_cmd->args[i] = NULL;\n\t\tif (current_token && current_token->type == TOKEN_PIPE)\n\t\t{\n\t\t\tcurrent_token = current_token->next;\n\t\t\tif (current_token == NULL || current_token->type == TOKEN_EOF)\n\t\t\t\treturn (syntax_error_handler(\"newline\"), NULL);\n\t\t}\n\t}\n\treturn (command_list);\n}",
  "PARSER/redirections.c": "#include \"parsing.h\"\n\nint\thandle_redirection(t_command *cmd, t_token **current_token_ptr)\n{\n\tt_token\t*redir_token;\n\tt_redir\t*new_redir;\n\n\tredir_token = *current_token_ptr;\n\tif (redir_token->next->type != TOKEN_WORD)\n\t{\n\t\treturn (syntax_error_handler(redir_token->next->value));\n\t}\n\tnew_redir = create_redir_node(redir_token->type, redir_token->next->value);\n\tadd_redir_node_back(&cmd->redirections, new_redir);\n\t*current_token_ptr = (*current_token_ptr)->next->next;\n\treturn (1);\n}",
  "PARSER/nodes/cmd_nodes.c": "#include \"parsing.h\"\n\nt_command\t*create_command_node(void)\n{\n\tt_command\t*new_cmd;\n\n\tnew_cmd = (t_command *)gc_mall(sizeof(t_command));\n\tnew_cmd->args = NULL;\n\tnew_cmd->redirections = NULL;\n\tnew_cmd->next_piped_command = NULL;\n\treturn (new_cmd);\n}\n\nvoid\tadd_command_node_back(t_command **list, t_command *new_cmd)\n{\n\tt_command\t*current;\n\n\tif (!list || !new_cmd)\n\t\treturn;\n\tif (*list == NULL)\n\t{\n\t\t*list = new_cmd;\n\t\treturn;\n\t}\n\tcurrent = *list;\n\twhile (current->next_piped_command != NULL)\n\t\tcurrent = current->next_piped_command;\n\tcurrent->next_piped_command = new_cmd;\n}",
  "PARSER/nodes/redir_nodes.c": "#include \"parsing.h\"\n\nstatic bool\tis_quoted(const char *str)\n{\n\tsize_t\tlen;\n\n\tif (!str)\n\t\treturn (false);\n\tlen = ft_strlen(str);\n\tif (len < 2)\n\t\treturn (false);\n\tif (str[0] == '\\'' && str[len - 1] == '\\'')\n\t\treturn (true);\n\tif (str[0] == '\\\"' && str[len - 1] == '\\\"')\n\t\treturn (true);\n\treturn (false);\n}\n\nt_redir\t*create_redir_node(t_token_type type, char *filename)\n{\n\tt_redir\t*new_redir;\n\n\tnew_redir = (t_redir *)gc_mall(sizeof(t_redir));\n\tif (type == TOKEN_REDIR_IN)\n\t\tnew_redir->type = REDIR_INPUT;\n\telse if (type == TOKEN_REDIR_OUT)\n\t\tnew_redir->type = REDIR_OUTPUT_TRUNC;\n\telse if (type == TOKEN_REDIR_APPEND)\n\t\tnew_redir->type = REDIR_OUTPUT_APPEND;\n\telse if (type == TOKEN_REDIR_HEREDOC)\n\t\tnew_redir->type = REDIR_HEREDOC;\n\tnew_redir->delimiter_or_filename = gc_strdup(filename);\n\tnew_redir->heredoc_fd = -1;\n\tnew_redir->expand_in_heredoc = !is_quoted(filename);\n\tnew_redir->next = NULL;\n\treturn (new_redir);\n}\n\nvoid\tadd_redir_node_back(t_redir **list, t_redir *new_redir)\n{\n\tt_redir\t*current;\n\n\tif (!list || !new_redir)\n\t\treturn;\n\tif (*list == NULL)\n\t{\n\t\t*list = new_redir;\n\t\treturn;\n\t}\n\tcurrent = *list;\n\twhile (current->next != NULL)\n\t\tcurrent = current->next;\n\tcurrent->next = new_redir;\n}",
  "TOKENIZER/nodes.c": "#include \"parsing.h\"\n\nt_token\t*create_token(t_token_type type, char *value)\n{\n\tt_token\t*new_token;\n\n\tnew_token = (t_token *)gc_mall(sizeof(t_token));\n\tnew_token->type = type;\n\tif (value)\n\t\tnew_token->value = gc_strdup(value);\n\telse\n\t\tnew_token->value = NULL;\n\tnew_token->next = NULL;\n\treturn (new_token);\n}\n\nvoid\tadd_token_back(t_token **list, t_token *new_token)\n{\n\tt_token\t*current;\n\n\tif (!list || !new_token)\n\t\treturn;\n\tif (*list == NULL)\n\t{\n\t\t*list = new_token;\n\t\treturn;\n\t}\n\tcurrent = *list;\n\twhile (current->next != NULL)\n\t{\n\t\tcurrent = current->next;\n\t}\n\tcurrent->next = new_token;\n}",
  "TOKENIZER/operators.c": "#include \"parsing.h\"\n\nt_token\t*get_operator_token(char *line, int *i)\n{\n\tif (line[*i] == '|')\n\t{\n\t\t(*i)++;\n\t\treturn (create_token(TOKEN_PIPE, \"|\"));\n\t}\n\tif (line[*i] == '>')\n\t{\n\t\t(*i)++;\n\t\tif (line[*i] == '>')\n\t\t{\n\t\t\t(*i)++;\n\t\t\treturn (create_token(TOKEN_REDIR_APPEND, \">>\"));\n\t\t}\n\t\treturn (create_token(TOKEN_REDIR_OUT, \">\"));\n\t}\n\tif (line[*i] == '<')\n\t{\n\t\t(*i)++;\n\t\tif (line[*i] == '<')\n\t\t{\n\t\t\t(*i)++;\n\t\t\treturn (create_token(TOKEN_REDIR_HEREDOC, \"<<\"));\n\t\t}\n\t\treturn (create_token(TOKEN_REDIR_IN, \"<\"));\n\t}\n\treturn (NULL);\n}\n",
  "TOKENIZER/tokenizer.c": "#include \"parsing.h\"\n\nt_token\t*tokenizer(char *line)\n{\n\tt_token\t*tokens;\n\tt_token\t*new_token;\n\tint\t\ti;\n\n\ttokens = NULL;\n\ti = 0;\n\twhile (line[i])\n\t{\n\t\tif (ft_isspace(line[i]))\n\t\t{\n\t\t\ti++;\n\t\t\tcontinue ;\n\t\t}\n\t\tif (is_metachar(line[i]))\n\t\t\tnew_token = get_operator_token(line, &i);\n\t\telse\n\t\t\tnew_token = get_word_token(line, &i);\n\t\tif (new_token == NULL)\n\t\t\treturn (NULL);\n\t\tadd_token_back(&tokens, new_token);\n\t}\n\tadd_token_back(&tokens, create_token(TOKEN_EOF, NULL));\n\treturn (tokens);\n}",
  "TOKENIZER/tools.c": "#include \"parsing.h\"\n\nint\tft_isspace(char c)\n{\n\treturn (c == ' ' || c == '\\t' || c == '\\n' || \\\n\t\t\tc == '\\v' || c == '\\f' || c == '\\r');\n}\n\nint\tis_metachar(char c)\n{\n\treturn (c == '|' || c == '<' || c == '>');\n}\nint\tis_unsupported_metachar(char c)\n{\n\tif (c == ';' || c == '\\\\' || c == '&' || c == '(' || c == ')' || \\\n\t\tc == '{' || c == '}')\n\t\treturn (1);\n\treturn (0);\n}",
  "TOKENIZER/words.c": "#include \"parsing.h\"\n\nstatic char\t*get_quoted_word(char *line, int *i)\n{\n\tchar\tquote_char;\n\tint\t\tstart;\n\tchar\t*word;\n\n\tquote_char = line[*i];\n\tstart = *i;\n\t(*i)++;\n\twhile (line[*i] && line[*i] != quote_char)\n\t\t(*i)++;\n\tif (line[*i] == '\\0')\n\t{\n\t\tft_putstr_fd(\"minishell: syntax error: unclosed quote\\n\", 2);\n\t\treturn (NULL);\n\t}\n\t(*i)++;\n\tword = ft_substr(line, start, *i - start);\n\tgc_add_pt(word);\n\treturn (word);\n}\n\nstatic char\t*get_regular_word(char *line, int *i)\n{\n\tint\t\tstart;\n\tchar\t*word;\n\n\tstart = *i;\n\twhile (line[*i] && !ft_isspace(line[*i]) && !is_metachar(line[*i]) \\\n\t\t&& line[*i] != '\\'' && line[*i] != '\\\"')\n\t{\n\t\t(*i)++;\n\t}\n\tword = ft_substr(line, start, *i - start);\n\tgc_add_pt(word);\n\treturn (word);\n}\n\nt_token\t*get_word_token(char *line, int *i)\n{\n\tchar\t*word_value;\n\n\tif (line[*i] == '\\'' || line[*i] == '\\\"')\n\t{\n\t\tword_value = get_quoted_word(line, i);\n\t\tif (word_value == NULL)\n\t\t\treturn (NULL);\n\t}\n\telse\n\t{\n\t\tword_value = get_regular_word(line, i);\n\t}\n\treturn (create_token(TOKEN_WORD, word_value));\n}",
  "tools/strings.c": "#include \"parsing.h\"\n\nint\tft_isalpha(int c)\n{\n\treturn ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'));\n}\n\nint\tft_isalnum(int c)\n{\n\treturn (ft_isalpha(c) || (c >= '0' && c <= '9'));\n}\n\nchar\t*ft_strjoin(char const *s1, char const *s2)\n{\n\tchar\t*new_str;\n\tsize_t\ti;\n\tsize_t\tj;\n\n\tif (!s1 || !s2)\n\t\treturn (NULL);\n\tnew_str = (char *)malloc(ft_strlen(s1) + ft_strlen(s2) + 1);\n\tif (!new_str)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (s1[i])\n\t{\n\t\tnew_str[i] = s1[i];\n\t\ti++;\n\t}\n\tj = 0;\n\twhile (s2[j])\n\t{\n\t\tnew_str[i + j] = s2[j];\n\t\tj++;\n\t}\n\tnew_str[i + j] = '\\0';\n\treturn (new_str);\n}\n\nint\tft_strncmp(const char *s1, const char *s2, size_t n)\n{\n\tsize_t\ti;\n\n\ti = 0;\n\tif (n == 0)\n\t\treturn (0);\n\twhile (i < n - 1 && s1[i] && s2[i] && s1[i] == s2[i])\n\t\ti++;\n\treturn ((unsigned char)s1[i] - (unsigned char)s2[i]);\n}\n\nchar\t*ft_strdup(char *value)\n{\n\tchar\t*result;\n\tint\t\ti;\n\tint\t\tlen;\n\n\tif (!value)\n\t\treturn (NULL);\n\tlen = ft_strlen(value);\n\tresult = malloc(sizeof(char) * (len + 1));\n\tif (!result)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (value[i] != '\\0')\n\t{\n\t\tresult[i] = value[i];\n\t\ti++;\n\t}\n\tresult[i] = '\\0';\n\treturn (result);\n}\n\nsize_t\tft_strlen(const char *s)\n{\n\tsize_t\ti;\n\n\ti = 0;\n\tif (!s)\n\t\treturn (0);\n\twhile (s[i])\n\t\ti++;\n\treturn (i);\n}\n\nvoid\tft_putstr_fd(const char *s, int fd)\n{\n\tif (s)\n\t\twrite(fd, s, ft_strlen(s));\n}\n\nchar\t*ft_substr(char const *s, unsigned int start, size_t len)\n{\n\tsize_t\ti;\n\tchar\t*r;\n\tsize_t\ts_len;\n\n\tif (!s)\n\t\treturn (NULL);\n\ts_len = ft_strlen(s);\n\tif (s_len < start)\n\t\treturn (ft_strdup(\"\"));\n\tif (len > s_len - start)\n\t\tlen = s_len - start;\n\tr = malloc(len + 1);\n\tif (!r)\n\t\treturn (NULL);\n\ti = 0;\n\twhile (i < len)\n\t{\n\t\tr[i] = s[start + i];\n\t\ti++;\n\t}\n\tr[i] = '\\0';\n\treturn (r);\n}"
}